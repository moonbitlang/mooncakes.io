{
  "readme": "# Option\n\nThe `Option` type is a built-in type in MoonBit that represents an optional value. The type annotation `Option[A]` can also be written as `A?`.\n\nIt is an enum with two variants: `Some(T)`, which represents a value of type `T`, and `None`, representing no value.\n\nNote that some methods of the Option are defined in the `core/builtin` package.\n\n# Usage\n\n## Create\nYou can create an `Option` value using the `Some` and `None` constructors, remember to give proper type annotations.\n\n```moonbit\nlet some: Int? = Some(42)\nlet none: String? = None\n```\n\nFor conditional expressions, you can use the `when` function, which returns `Some` if the condition is true, otherwise `None`. Note that the value is lazily evaluated.\n\n```moonbit\nlet some = @option.when(1 > 0, fn () { 42 }) // Some(42)\nlet none = @option.when(1 < 0, fn () { 42 }) // None\n```\n\nThe dual version of `when` is the `unless` function, which returns `Some` if the condition is false, otherwise `None`.\n\n```moonbit\nlet some = @option.unless(1 < 0, fn () { 42 }) // Some(42)\nlet none = @option.unless(1 > 0, fn () { 42 }) // None\n```\n\n## Extracting values\n\nYou can extract the value from an `Option` using the `match` expression (Pattern Matching).\n\n```moonbit\nmatch some {\n    Some(value) => print(value)\n    None => print(\"None\")\n}\n```\n\nOr using the `unwrap` method, which will panic if the result is `None` and return the value if it is `Some`.\n\n```moonbit\nlet some: Int? = Some(42)\nlet value = some.unwrap() // 42\n```\n\nA safer alternative to `unwrap` is the `or` method, which returns the value if it is `Some`, otherwise, it returns the default value.\n\n```moonbit\nlet none: Int? = None\nlet value = none.or(0) // 0\n```\n\nThere is also the `or_else` method, which returns the value if it is `Some`, otherwise, it returns the result of the provided function.\n\n```moonbit\nlet none: Int? = None\nlet value = none.or_else(fn() -> Int { 0 }) // 0\n```\n\n## Transforming values\n\nYou can transform the value of an `Option` using the `map` method. It applies the provided function to the value if it is `Some`, otherwise, it returns `None`.\n\n```moonbit\nlet some: Int? = Some(42)\nlet new_some = some.map(fn(value: Int) { value + 1 }) // Some(43)\n```\n\nThere is a `filter` method that applies a predicate to the value if it is `Some`, otherwise, it returns `None`.\n\n```moonbit\nlet some: Int? = Some(42)\nlet new_some = some.filter(fn(value: Int) { value > 40 }) // Some(42)\nlet none = some.filter(fn(value: Int) { value > 50 }) // None\n```\n\n## Monadic operations\nYou can chain multiple operations that return `Option` using the `bind` method, which applies a function to the value if it is `Some`, otherwise, it returns `None`. Different from `map`, the function in argument returns an `Option`.\n\n```moonbit\nlet some: Int? = Some(42)\nlet new_some = some.bind(fn(value: Int) -> Int? { Some(value + 1) }) // Some(43)\n```\n\nSometimes we want to reduce the nested `Option` values into a single `Option`, you can use the `flatten` method to achieve this. It transforms `Some(Some(value))` into `Some(value)`, and `None` otherwise.\n\n```moonbit\nlet some: Option[Option[Int]] = Some(Some(42))\nlet new_some = some.flatten() // Some(42)\nlet none: Int?? = Some(None)\nlet new_none = none.flatten() // None\n```\n",
  "name": "moonbitlang/core/option",
  "traits": [],
  "types": [],
  "typealias": [],
  "values": [
    {
      "name": "empty",
      "docstring": "\n Creates an empty `Option` of type `T`.",
      "signature": "fn empty[T]() -> T?",
      "loc": { "line": 75, "column": 8 }
    },
    {
      "name": "some",
      "docstring": "\n Creates an `Option` that contains a value.",
      "signature": "fn some[T](value : T) -> T?",
      "loc": { "line": 87, "column": 8 }
    },
    {
      "name": "unless",
      "docstring": "\n The `unless` function returns an `Option` value based on a condition.\n\n `unless(condition, value)` is equivalent to `when(not(condition), value)`.\n\n # Arguments\n\n * `condition`: A boolean value indicating whether the condition is true or false.\n * `value`: A function that returns a value of type `T`.\n\n # Returns\n\n An `Option` value that is `Some(value())` if the condition is false, otherwise `None`.\n",
      "signature": "fn unless[T](condition : Bool, value : () -> T) -> T?",
      "loc": { "line": 62, "column": 8 }
    },
    {
      "name": "when",
      "docstring": "\n Creates an `Option` containing a value if the given condition is true, otherwise returns `None`.\n\n # Arguments\n\n * `condition`: A boolean value indicating whether the option should contain a value.\n * `value`: A function that returns the value to be contained in the option.\n\n # Returns\n\n An `Option` containing the value if the condition is true, otherwise `None`.\n\n # Example\n\n ```\n let result = @option.when(true, fn(){ \"Hello, World!\" })\n assert_eq!(result, Some(\"Hello, World!\"))\n ```",
      "signature": "fn when[T](condition : Bool, value : () -> T) -> T?",
      "loc": { "line": 33, "column": 8 }
    }
  ],
  "misc": [
    {
      "name": "Option",
      "impls": [
        {
          "name": "arbitrary",
          "docstring": "",
          "signature": "impl <a href=\"moonbitlang/core/quickcheck#Arbitrary\">@moonbitlang/core/quickcheck.Arbitrary</a> for <a href=\"moonbitlang/core/option#Option\">Option</a> with arbitrary[X : <a href=\"moonbitlang/core/quickcheck#Arbitrary\">@moonbitlang/core/quickcheck.Arbitrary</a>](i : Int, rs : <a href=\"moonbitlang/core/quickcheck/splitmix#RandomState\">@moonbitlang/core/quickcheck/splitmix.RandomState</a>) -> X?",
          "loc": { "line": 410, "column": 71 }
        }
      ],
      "methods": [
        {
          "name": "arbitrary",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/option#Option\">Option</a>::arbitrary[X : <a href=\"moonbitlang/core/quickcheck#Arbitrary\">@moonbitlang/core/quickcheck.Arbitrary</a>](i : Int, rs : <a href=\"moonbitlang/core/quickcheck/splitmix#RandomState\">@moonbitlang/core/quickcheck/splitmix.RandomState</a>) -> X?",
          "loc": { "line": 410, "column": 71 }
        },
        {
          "name": "bind",
          "docstring": "\n Binds an option to a function that returns another option.\n\n # Example\n\n ```\n let a = Option::Some(5)\n let r1 = a.bind(fn(x){ Some(x * 2) })\n assert_eq!(r1, Some(10))\n let b : Option[Int] = None\n let r2 = b.bind(fn(x){ Some(x * 2) })\n assert_eq!(r2, None)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/option#Option\">Option</a>::bind[T, U](self : T?, f : (T) -> U?) -> U?",
          "loc": { "line": 184, "column": 8 }
        },
        {
          "name": "compare",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/option#Option\">Option</a>::compare[X : <a href=\"moonbitlang/core/builtin#Compare\">Compare</a> + <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : X?, other : X?) -> Int",
          "loc": { "line": 314, "column": 8 }
        },
        {
          "name": "default",
          "docstring": "\n `None`",
          "signature": "fn <a href=\"moonbitlang/core/option#Option\">Option</a>::default[X]() -> X?",
          "loc": { "line": 343, "column": 16 }
        },
        {
          "name": "filter",
          "docstring": "\n Filters the option by applying the given predicate function `f`.\n\n If the predicate function `f` returns `true` for the value contained in the option,\n the same option is returned. Otherwise, `None` is returned.\n\n # Example\n ```\n let x = Some(3)\n assert_eq!(x.filter(fn(x){ x > 5 }), None)\n assert_eq!(x.filter(fn(x){ x < 5 }), Some(3))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/option#Option\">Option</a>::filter[T](self : T?, f : (T) -> Bool) -> T?",
          "loc": { "line": 253, "column": 8 }
        },
        {
          "name": "flatten",
          "docstring": "\n Flattens an `Option` of `Option` into a single `Option`.\n\n If the input `Option` is `Some(Some(value))`, the function returns `Some(value)`.\n\n # Example\n\n ```\n let a = Some(Some(42));\n assert_eq!(@option.flatten(a), Some(42))\n let b : Int?? = Some(None)\n assert_eq!(@option.flatten(b), None)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/option#Option\">Option</a>::flatten[T](self : T??) -> T?",
          "loc": { "line": 211, "column": 8 }
        },
        {
          "name": "is_empty",
          "docstring": "\n Checks if the option is empty.",
          "signature": "fn <a href=\"moonbitlang/core/option#Option\">Option</a>::is_empty[T](self : T?) -> Bool",
          "loc": { "line": 227, "column": 8 }
        },
        {
          "name": "iter",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/option#Option\">Option</a>::iter[T](self : T?) -> <a href=\"moonbitlang/core/builtin#Iter\">Iter</a>[T]",
          "loc": { "line": 348, "column": 8 }
        },
        {
          "name": "map",
          "docstring": "\n Maps the value of an `Option` using a provided function.\n\n # Example\n\n ```\n let a = Some(5)\n assert_eq!(a.map(fn(x){ x * 2 }), Some(10))\n\n let b = None\n assert_eq!(b.map(fn(x){ x * 2 }), None)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/option#Option\">Option</a>::map[T, U](self : T?, f : (T) -> U) -> U?",
          "loc": { "line": 109, "column": 8 }
        },
        {
          "name": "map_or",
          "docstring": "\n Returns the provided default result (if none), or applies a function to the contained value (if any).\n Arguments passed to map_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use `map_or_else`, which is lazily evaluated.\n\n # Example\n\n ```\n let a = Some(5)\n assert_eq!(a.map_or(3, fn(x){ x * 2 }), 10)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/option#Option\">Option</a>::map_or[T, U](self : T?, default : U, f : (T) -> U) -> U",
          "loc": { "line": 133, "column": 8 }
        },
        {
          "name": "map_or_else",
          "docstring": "\n Computes a default function result (if none), or applies a different function to the contained value (if any).\n \n # Example\n\n ```\n let a = Some(5)\n assert_eq!(a.map_or_else(fn(){ 3 }, fn(x){ x * 2 }), 10)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/option#Option\">Option</a>::map_or_else[T, U](self : T?, default : () -> U, f : (T) -> U) -> U",
          "loc": { "line": 156, "column": 8 }
        },
        {
          "name": "or",
          "docstring": "\n Return the contained `Some` value or the provided default.",
          "signature": "fn <a href=\"moonbitlang/core/option#Option\">Option</a>::or[T](self : T?, default : T) -> T",
          "loc": { "line": 268, "column": 8 }
        },
        {
          "name": "or_default",
          "docstring": "\n Return the contained `Some` value or the result of the `T::default()`.",
          "signature": "fn <a href=\"moonbitlang/core/option#Option\">Option</a>::or_default[T : <a href=\"moonbitlang/core/builtin#Default\">Default</a>](self : T?) -> T",
          "loc": { "line": 300, "column": 8 }
        },
        {
          "name": "or_else",
          "docstring": "\n Return the contained `Some` value or the provided default.\n\n Default is lazily evaluated",
          "signature": "fn <a href=\"moonbitlang/core/option#Option\">Option</a>::or_else[T](self : T?, default : () -> T) -> T",
          "loc": { "line": 285, "column": 8 }
        },
        {
          "name": "or_error",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/option#Option\">Option</a>::or_error[T, Err : <a href=\"moonbitlang/core/error#Error\">Error</a>](self : T?, err : Err) -> T!Err",
          "loc": { "line": 383, "column": 8 }
        }
      ]
    }
  ]
}