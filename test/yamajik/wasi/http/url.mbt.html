<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Moonbit docs</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="Description">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/one-light.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script
    src="//cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
</head>

<body>
  <pre><code class="moonbit">///|
type! URLParseError {
  InvalidURL(String)
  InvalidScheme(String)
} derive(Show)

///|
enum Scheme {
  Http
  Https
  Other(String)
} derive(Show)

///|
pub fn Scheme::to_string(self : Scheme) -> String {
  match self {
    Scheme::Http => "http"
    Scheme::Https => "https"
    Scheme::Other(s) => s
  }
}

///|
fn Scheme::from_string(s : String) -> Scheme {
  match s {
    "http" => Scheme::Http
    "https" => Scheme::Https
    _ => Scheme::Other(s)
  }
}

///|
fn Scheme::to_wasi(self : Scheme) -> @types.Scheme {
  match self {
    Scheme::Http => @types.Scheme::Http
    Scheme::Https => @types.Scheme::Https
    Scheme::Other(s) => @types.Scheme::Other(s)
  }
}

///|
fn Scheme::from_wasi(s : @types.Scheme) -> Scheme {
  match s {
    @types.Scheme::Http => Scheme::Http
    @types.Scheme::Https => Scheme::Https
    @types.Scheme::Other(s) => Scheme::Other(s)
  }
}

///|
type Query Map[String, String] derive(Show)

///|
fn Query::new() -> Query {
  Map::new()
}

///|
pub fn Query::to_string(self : Query) -> String {
  if self._.is_empty() {
    return ""
  }
  let parts = self._.iter().map(fn { (k, v) => "\{k}=\{v}" }).collect()
  "?" + String::concat(parts, separator="&")
}

///|
fn Query::set(self : Query, key : String, value : String) -> Unit {
  self._.set(key, value)
}

///|
fn Query::get(self : Query, key : String) -> String? {
  self._.get(key)
}

///|
type Authority String derive(Show)

///|
pub fn Authority::to_string(self : Authority) -> String {
  self._
}

///|
type Path String derive(Show)

///|
pub fn Path::to_string(self : Path) -> String {
  self._
}

///|
pub fn Path::starts_with(self : Path, prefix : String) -> Bool {
  self._.starts_with(prefix)
}

///|
pub fn Path::parts(self : Path, skip_prefix~ : String = "") -> Array[String] {
  let mut s = self._
  if skip_prefix.is_empty() != true && self._.starts_with(skip_prefix) {
    s = self._.substring(start=skip_prefix.length())
  }
  s.split("/").filter(fn { p => p != "" }).collect()
}

///|
pub(readonly) struct URL {
  scheme : Scheme
  authority : Authority
  path : Path
  query : Query
} derive(Show)

///|
pub fn URL::parse(url : String) -> URL!URLParseError {
  URLParser::parse!(url)
}

///|
pub fn URL::parse_path_with_query(
  scheme : Scheme,
  authority : String,
  path_with_query : String
) -> URL {
  let (path, query) = URLParser::parse_path_with_query(path_with_query)
  { scheme, authority, path, query }
}

///|
pub fn URL::to_string(self : URL) -> String {
  "\{self.scheme}://\{self.authority}\{self.path}\{self.query}"
}

///|
pub fn URL::path_with_query(self : URL) -> String {
  "\{self.path}\{self.query}"
}

///|
struct URLParser {}

///|
fn URLParser::parse(url : String) -> URL!URLParseError {
  let (scheme, rest) = URLParser::parse_scheme!(url)
  let (authority, path_with_query) = URLParser::parse_authority(rest)
  let (path, query) = URLParser::parse_path_with_query(path_with_query)
  { scheme, authority, path, query }
}

///|
fn URLParser::parse_scheme(url : String) -> (Scheme, String)!URLParseError {
  guard let (scheme_string, rest) = URLParser::split_2(url, seperator="://") else {
    (_, "") => raise URLParseError::InvalidURL(url)
  }
  guard let scheme = Scheme::from_string(scheme_string) else {
    Scheme::Other(s) => raise URLParseError::InvalidScheme(s)
  }
  (scheme, rest)
}

///|
fn URLParser::parse_authority(url : String) -> (Authority, String) {
  let (authority, rest) = URLParser::split_2(
    url,
    seperator="/",
    keep_seperator=true,
  )
  (authority, rest)
}

///|
fn URLParser::parse_path_with_query(url : String) -> (Path, Query) {
  match URLParser::split_2(url, seperator="?") {
    (path, "") => (path, Query::new())
    (path, query_string) => (path, URLParser::parse_query(query_string))
  }
}

///|
fn URLParser::parse_query(url : String) -> Query {
  let query = Query::new()
  for part in url.split("&") {
    match URLParser::split_2(part, seperator="=") {
      (key, "") => query.set(key, "")
      (key, value) => query.set(key, value)
    }
  }
  query
}

///|
fn URLParser::split_2(
  s : String,
  seperator~ : String,
  keep_seperator~ : Bool = false
) -> (String, String) {
  match s.index_of(seperator) {
    -1 => (s, "")
    end => {
      let start = if keep_seperator { end } else { end + seperator.length() }
      (s.substring(end~), s.substring(start~))
    }
  }
}
</code></pre>
  <script>
    let moonbitLanguageFn = hljs => {
      return {
        case_insensitive: true,
        keywords: {
          keyword: 'func fn enum struct type if else match return continue break while let var interface pub priv readonly',
          literal: 'true false',
          type: "Int Int64 Double String Bool Char Bytes Option Array Result",
          built_in: 'lsl lsr asr shl shr land lor lxor Show Debug Hash Eq Compare Some None'
        },
        contains: [
          {
            scope: "char",
            begin: "'", end: "'"
          },
          {
            scope: "string",
            begin: "\"", end: "\""
          },
          {
            scope: "number",
            begin: "\\b\\d+(\\.\\d+)?\\b"
          },
          {
            scope: "codelink",
            match: /\<a href\="(?<link>[^<>]+?)"\>(?<code>[^\/<>]+?)\<\/a\>/g
          },
          hljs.COMMENT(
            '//', // begin
            '\n', // end
          )
        ]
      }
    }

    hljs.registerLanguage('moonbit', moonbitLanguageFn);
    hljs.highlightAll();
    hljs.initLineNumbersOnLoad();

    const number = window.location.href.split('#')[1];

    function waitForLineNumbers() {
      setTimeout(function () {
        const target = document.querySelector(`.hljs-ln-line[data-line-number="${number}"]`);
        if (target == null) waitForLineNumbers();
        else target.scrollIntoView();
      }, 50);
    }

    waitForLineNumbers()

  </script>
  <style>
    .hljs-ln-numbers {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    .hljs-ln-n {
      color: #ccc;
      border-right: 1px solid #dfdddd;
      margin-right: 1em;
      text-align: center;
      vertical-align: top;
      padding-right: 0.5em;
    }

    .hljs {
      background: none;
    }

    body {
      background-color: #fafafa;
    }
  </style>
</body>

</html>