{
  "readme": "# gmlewis/hash\n[![check](https://github.com/gmlewis/moonbit-hash/actions/workflows/check.yml/badge.svg)](https://github.com/gmlewis/moonbit-hash/actions/workflows/check.yml)\n\nThis package provides hash functions based on Go's implementation:\nhttps://cs.opensource.google/go/go/+/refs/tags/go1.23.3:src/hash/hash.go;l=26\nwhich has the copyright notice:\n\n```\n// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n```\n\n## Status\n\nThe code has been updated to support compiler:\n\n```bash\n$ moon version --all\nmoon 0.1.20241216 (b57ed1c 2024-12-16) ~/.moon/bin/moon\nmoonc v0.1.20241216+68e710374 ~/.moon/bin/moonc\nmoonrun 0.1.20241216 (b57ed1c 2024-12-16) ~/.moon/bin/moonrun\n```\n\nUse `moonup` to manage `moon` compiler versions:\nhttps://github.com/chawyehsu/moonup\n",
  "name": "gmlewis/hash",
  "traits": [
    {
      "name": "@gmlewis/hash.Hash",
      "docstring": " Hash is the common interface implemented by all hash functions.\n\n Hash implementations in the standard library (e.g. [hash/crc32] and\n [crypto/sha256]) implement the [encoding.BinaryMarshaler] and\n [encoding.BinaryUnmarshaler] interfaces. Marshaling a hash implementation\n allows its internal state to be saved and used for additional processing\n later, without having to re-write the data previously written to the hash.\n The hash state may contain portions of the input in its original form,\n which users are expected to handle for any possible security implications.\n\n Compatibility: Any future changes to hash or crypto packages will endeavor\n to maintain compatibility with state encoded using previous versions.\n That is, any released versions of the packages should be able to\n decode data written with any previously released version,\n subject to issues such as security fixes.\n See the Go compatibility document for background: https://golang.org/doc/go1compat",
      "signature": "pub(open) trait @gmlewis/hash.Hash {\n  write(Self, <a href=\"gmlewis/io#Slice\">@gmlewis/io.Slice</a>[Byte]) -> (Int, <a href=\"gmlewis/io#IOError\">@gmlewis/io.IOError</a>?)\n  sum(Self, <a href=\"gmlewis/io#Slice\">@gmlewis/io.Slice</a>[Byte]) -> <a href=\"gmlewis/io#Slice\">@gmlewis/io.Slice</a>[Byte]\n  reset(Self) -> Unit\n  size(Self) -> Int\n  block_size(Self) -> Int\n}",
      "loc": { "line": 30, "column": 1 },
      "default_impls": [],
      "impls": []
    },
    {
      "name": "@gmlewis/hash.Hash32",
      "docstring": " Hash32 is the common interface implemented by all 32-bit hash functions.",
      "signature": "pub(open) trait @gmlewis/hash.Hash32 {\n  sum32(Self) -> UInt\n  write(Self, <a href=\"gmlewis/io#Slice\">@gmlewis/io.Slice</a>[Byte]) -> (Int, <a href=\"gmlewis/io#IOError\">@gmlewis/io.IOError</a>?)\n  sum(Self, <a href=\"gmlewis/io#Slice\">@gmlewis/io.Slice</a>[Byte]) -> <a href=\"gmlewis/io#Slice\">@gmlewis/io.Slice</a>[Byte]\n  reset(Self) -> Unit\n  size(Self) -> Int\n  block_size(Self) -> Int\n}",
      "loc": { "line": 54, "column": 1 },
      "default_impls": [],
      "impls": []
    },
    {
      "name": "@gmlewis/hash.Hash64",
      "docstring": " Hash64 is the common interface implemented by all 64-bit hash functions.",
      "signature": "pub(open) trait @gmlewis/hash.Hash64 {\n  sum64() -> UInt64\n  write(Self, <a href=\"gmlewis/io#Slice\">@gmlewis/io.Slice</a>[Byte]) -> (Int, <a href=\"gmlewis/io#IOError\">@gmlewis/io.IOError</a>?)\n  sum(Self, <a href=\"gmlewis/io#Slice\">@gmlewis/io.Slice</a>[Byte]) -> <a href=\"gmlewis/io#Slice\">@gmlewis/io.Slice</a>[Byte]\n  reset(Self) -> Unit\n  size(Self) -> Int\n  block_size(Self) -> Int\n}",
      "loc": { "line": 65, "column": 1 },
      "default_impls": [],
      "impls": []
    }
  ],
  "types": [],
  "typealias": [],
  "values": [],
  "misc": []
}