<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Moonbit docs</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="Description">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/one-light.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script
    src="//cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
</head>

<body>
  <pre><code class="moonbit">
///|
struct Lexbuf {
   content : String
   mut pos : Int
 }

///|
pub fn Lexbuf::from_string(content : String) -> Lexbuf {
   { content, pos: 0 }
 }

// NOTE: MoonBit do have unboxed Option[Char] optimization
///|
fn next(self : Lexbuf) -> Char? {
   if self.pos < self.content.length() {
     let ch = self.content[self.pos]
     self.pos += 1
     Some(ch)
   } else {
     None
   }
 }

///|
fn substring(self : Lexbuf, start : Int, end : Int) -> String {
   self.content.substring(start~, end~)
 }

///|
typealias LexTagAction = Array[Array[Int]]

///|
typealias LexState = Int

///|
typealias LexInput = Int

///|
pub(all) struct LexEngine {
   graph : Array[(LexState) -> (LexState, LexTagAction)]
   end_nodes : Array[(Int, Array[((Int, Int), (Int, Int))])?]
   start_tags : Array[Int]
   code_blocks_n : Int
 }

///|
pub fn run(self : LexEngine, lexbuf : Lexbuf) -> (Int, Array[(Int, Int)]) {
   let mut state = 1
   let mut tagState : Array[Array[Int]] = []
   let backtrace = Array::make(self.code_blocks_n, None)
   for tag in self.start_tags {
     while tagState.length() <= tag {
       tagState.push([])
     }
     tagState[tag].push(lexbuf.pos)
   }
   while state != 0 {
     match self.end_nodes[state] {
       Some(t) => backtrace[t.0] = Some((lexbuf.pos, state, tagState))
       _ => ()
     }
     let b = match lexbuf.next() {
       Some(b) => b
       None => '\x00'
     }
     let next = self.graph[state](b.to_int())
     state = next.0
     let new_tagState : Array[Array[Int]] = []
     for i = 0; i < next.1.length(); i = i + 1 {
       new_tagState.push([])
       for j = 0; j < next.1[i].length(); j = j + 1 {
         let t = next.1[i][j]
         if t == -1 {
           new_tagState[i].push(lexbuf.pos)
         } else {
           new_tagState[i].push(tagState[i][t])
         }
       }
     }
     tagState = new_tagState
   }
   for index, b in backtrace {
     match b {
       Some((p, state, tagState)) => {
         lexbuf.pos = p
         let captures = self.end_nodes[state].unwrap().1.map(
           fn {
             ((b_t, b_r), (e_t, e_r)) => (tagState[b_t][b_r], tagState[e_t][e_r])
           },
         )
         break (index, captures)
       }
       None => ()
     }
   } else {
     (self.code_blocks_n, [])
   }
 }



// translate from https://ohama.github.io/ocaml/ocamllex-tutorial/examples/wordcount/


let count_tag_action_row_0 : Array[Int] = []
let count_tag_action_row_2 : Array[Int] = [-1]
let count_tag_action_row_1 : Array[Int] = [0]

let count_tag_action_1 : Array[Array[Int]] = [count_tag_action_row_0, count_tag_action_row_0]
let count_tag_action_0 : Array[Array[Int]] = [count_tag_action_row_1, count_tag_action_row_2]

fn count_state_0(input : LexInput) -> (LexState, LexTagAction) {
   match input {
     _ => (0, [])
   }
 }
fn count_state_1(input : LexInput) -> (LexState, LexTagAction) {
   match input {
     1..=8 => (2, count_tag_action_0)
     9 => (4, count_tag_action_1)
     10 => (3, count_tag_action_1)
     11..=31 => (2, count_tag_action_0)
     32 => (4, count_tag_action_1)
     33..=127 => (2, count_tag_action_0)
     _ => (0, [])
   }
 }
fn count_state_2(input : LexInput) -> (LexState, LexTagAction) {
   match input {
     1..=8 => (5, count_tag_action_0)
     11..=31 => (5, count_tag_action_0)
     33..=127 => (5, count_tag_action_0)
     _ => (0, [])
   }
 }
fn count_state_3(input : LexInput) -> (LexState, LexTagAction) {
   match input {
     _ => (0, [])
   }
 }
fn count_state_4(input : LexInput) -> (LexState, LexTagAction) {
   match input {
     _ => (0, [])
   }
 }
fn count_state_5(input : LexInput) -> (LexState, LexTagAction) {
   match input {
     1..=8 => (5, count_tag_action_0)
     11..=31 => (5, count_tag_action_0)
     33..=127 => (5, count_tag_action_0)
     _ => (0, [])
   }
 }

let __mbtlex_engine_count: LexEngine = { graph: [count_state_0, count_state_1, count_state_2, count_state_3, count_state_4, count_state_5, ], end_nodes: [None, Some((3, [])), Some((1, [((0, 0), (1, 0))])), Some((0, [])), Some((2, [])), Some((1, [((0, 0), (1, 0))]))], start_tags: [0], code_blocks_n: 4 }
fn count( lines :  Int, words :  Int, chars :  Int, lexbuf : Lexbuf ) ->  (Int, Int, Int)  {
 match __mbtlex_engine_count.run(lexbuf) {
 (0, __mbtlex_captures) => {
  count(lines + 1, words, chars + 1, lexbuf) 
 }
 (1, __mbtlex_captures) => {
 let (_start_pos_of_word, _end_pos_of_word) = __mbtlex_captures[0]
 let word: String = lexbuf.substring(_start_pos_of_word, _end_pos_of_word)
 
 
       let new_chars = chars + word.length()
       count(lines, words + 1, new_chars, lexbuf)
     
 }
 (2, __mbtlex_captures) => {
  count(lines, words, chars + 1, lexbuf) 
 }
 (3, __mbtlex_captures) => {
  (lines, words, chars) 
 }
 _ => abort("lex: fail to match")
 }
 }


</code></pre>
  <script>
    let moonbitLanguageFn = hljs => {
      return {
        case_insensitive: true,
        keywords: {
          keyword: 'func fn enum struct type if else match return continue break while let var interface pub priv readonly',
          literal: 'true false',
          type: "Int Int64 Double String Bool Char Bytes Option Array Result",
          built_in: 'lsl lsr asr shl shr land lor lxor Show Debug Hash Eq Compare Some None'
        },
        contains: [
          {
            scope: "char",
            begin: "'", end: "'"
          },
          {
            scope: "string",
            begin: "\"", end: "\""
          },
          {
            scope: "number",
            begin: "\\b\\d+(\\.\\d+)?\\b"
          },
          {
            scope: "codelink",
            match: /\<a href\="(?<link>[^<>]+?)"\>(?<code>[^\/<>]+?)\<\/a\>/g
          },
          hljs.COMMENT(
            '//', // begin
            '\n', // end
          )
        ]
      }
    }

    hljs.registerLanguage('moonbit', moonbitLanguageFn);
    hljs.highlightAll();
    hljs.initLineNumbersOnLoad();

    const number = window.location.href.split('#')[1];

    function waitForLineNumbers() {
      setTimeout(function () {
        const target = document.querySelector(`.hljs-ln-line[data-line-number="${number}"]`);
        if (target == null) waitForLineNumbers();
        else target.scrollIntoView();
      }, 50);
    }

    waitForLineNumbers()

  </script>
  <style>
    .hljs-ln-numbers {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    .hljs-ln-n {
      color: #ccc;
      border-right: 1px solid #dfdddd;
      margin-right: 1em;
      text-align: center;
      vertical-align: top;
      padding-right: 0.5em;
    }

    .hljs {
      background: none;
    }

    body {
      background-color: #fafafa;
    }
  </style>
</body>

</html>