{
  "readme": "# gmlewis/gzip\n[![check](https://github.com/gmlewis/moonbit-gzip/actions/workflows/check.yml/badge.svg)](https://github.com/gmlewis/moonbit-gzip/actions/workflows/check.yml)\n\nThis is a simplified gzip/gunzip algorithm based on Go's implementation:\nhttps://cs.opensource.google/go/go/+/refs/tags/go1.23.0:src/compress/gzip/gzip.go\nwhich has the copyright notice:\n\n```\n// Copyright 2010 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n```\n\n## Status\n\nThe code has been updated to support compiler:\n\n```bash\n$ moon version --all\nmoon 0.1.20241216 (b57ed1c 2024-12-16) ~/.moon/bin/moon\nmoonc v0.1.20241216+68e710374 ~/.moon/bin/moonc\nmoonrun 0.1.20241216 (b57ed1c 2024-12-16) ~/.moon/bin/moonrun\n```\n\nUse `moonup` to manage `moon` compiler versions:\nhttps://github.com/chawyehsu/moonup\n",
  "name": "gmlewis/gzip",
  "traits": [],
  "types": [
    {
      "name": "CompressionLevel",
      "docstring": "",
      "signature": "pub(all) type CompressionLevel Int",
      "loc": { "line": 11, "column": 15 },
      "methods": [],
      "impls": [
        {
          "docstring": "",
          "signature": "impl <a href=\"moonbitlang/core/builtin#Compare\">Compare</a> for <a href=\"gmlewis/gzip#CompressionLevel\">CompressionLevel</a>",
          "methods": [
            {
              "name": "compare",
              "docstring": "automatically derived",
              "signature": "fn compare(<a href=\"gmlewis/gzip#CompressionLevel\">CompressionLevel</a>, <a href=\"gmlewis/gzip#CompressionLevel\">CompressionLevel</a>) -> Int",
              "loc": { "line": 11, "column": 49 }
            }
          ],
          "loc": { "line": 11, "column": 49 }
        },
        {
          "docstring": "",
          "signature": "impl <a href=\"moonbitlang/core/builtin#Eq\">Eq</a> for <a href=\"gmlewis/gzip#CompressionLevel\">CompressionLevel</a>",
          "methods": [
            {
              "name": "op_equal",
              "docstring": "automatically derived",
              "signature": "fn op_equal(<a href=\"gmlewis/gzip#CompressionLevel\">CompressionLevel</a>, <a href=\"gmlewis/gzip#CompressionLevel\">CompressionLevel</a>) -> Bool",
              "loc": { "line": 11, "column": 58 }
            }
          ],
          "loc": { "line": 11, "column": 58 }
        },
        {
          "docstring": "",
          "signature": "impl <a href=\"moonbitlang/core/builtin#Show\">Show</a> for <a href=\"gmlewis/gzip#CompressionLevel\">CompressionLevel</a>",
          "methods": [
            {
              "name": "output",
              "docstring": "automatically derived",
              "signature": "fn output(<a href=\"gmlewis/gzip#CompressionLevel\">CompressionLevel</a>, <a href=\"moonbitlang/core/builtin#Logger\">Logger</a>) -> Unit",
              "loc": { "line": 11, "column": 43 }
            }
          ],
          "loc": { "line": 11, "column": 43 }
        }
      ]
    },
    {
      "name": "Header",
      "docstring": " The gzip file stores a header giving metadata about the compressed file.\n That header is exposed as the fields of the [Writer] and [Reader] structs.\n\n Strings must be UTF-8 encoded and may only contain Unicode code points\n U+0001 through U+00FF, due to limitations of the GZIP file format.",
      "signature": "pub(all) struct Header {\n  comment : String\n  extra : <a href=\"moonbitlang/core/array#Array\">Array</a>[Byte]\n  mod_time : <a href=\"moonbitlang/x/time#PlainDateTime\">@moonbitlang/x/time.PlainDateTime</a>?\n  name : String\n  os : Byte\n}",
      "loc": { "line": 69, "column": 17 },
      "methods": [
        {
          "name": "new",
          "docstring": "",
          "signature": "fn <a href=\"gmlewis/gzip#Header\">Header</a>::new() -> <a href=\"gmlewis/gzip#Header\">Header</a>",
          "loc": { "line": 78, "column": 16 }
        }
      ],
      "impls": []
    },
    {
      "name": "Reader",
      "docstring": "",
      "signature": "pub(all) struct Reader {\n  header : <a href=\"gmlewis/gzip#Header\">Header</a>\n  // private fields\n}",
      "loc": { "line": 97, "column": 17 },
      "methods": [
        {
          "name": "close",
          "docstring": "",
          "signature": "fn <a href=\"gmlewis/gzip#Reader\">Reader</a>::close(self : <a href=\"gmlewis/gzip#Reader\">Reader</a>) -> <a href=\"gmlewis/io#IOError\">@gmlewis/io.IOError</a>?",
          "loc": { "line": 425, "column": 8 }
        },
        {
          "name": "multistream",
          "docstring": "",
          "signature": "fn <a href=\"gmlewis/gzip#Reader\">Reader</a>::multistream(self : <a href=\"gmlewis/gzip#Reader\">Reader</a>, ok : Bool) -> Unit",
          "loc": { "line": 162, "column": 8 }
        },
        {
          "name": "new",
          "docstring": "",
          "signature": "fn <a href=\"gmlewis/gzip#Reader\">Reader</a>::new(r : <a href=\"gmlewis/flate#Reader\">@gmlewis/flate.Reader</a>) -> (<a href=\"gmlewis/gzip#Reader\">Reader</a>, <a href=\"gmlewis/io#IOError\">@gmlewis/io.IOError</a>?)",
          "loc": { "line": 114, "column": 16 }
        },
        {
          "name": "read",
          "docstring": "",
          "signature": "fn <a href=\"gmlewis/gzip#Reader\">Reader</a>::read(self : <a href=\"gmlewis/gzip#Reader\">Reader</a>, p : <a href=\"gmlewis/io#Slice\">@gmlewis/io.Slice</a>[Byte]) -> (Int, <a href=\"gmlewis/io#IOError\">@gmlewis/io.IOError</a>?)",
          "loc": { "line": 364, "column": 8 }
        },
        {
          "name": "reset",
          "docstring": "",
          "signature": "fn <a href=\"gmlewis/gzip#Reader\">Reader</a>::reset(self : <a href=\"gmlewis/gzip#Reader\">Reader</a>, r : <a href=\"gmlewis/flate#Reader\">@gmlewis/flate.Reader</a>) -> <a href=\"gmlewis/io#IOError\">@gmlewis/io.IOError</a>?",
          "loc": { "line": 133, "column": 8 }
        }
      ],
      "impls": []
    },
    {
      "name": "Writer",
      "docstring": " Writes to a Writer are compressed and written to w.",
      "signature": "pub(all) struct Writer {\n  header : <a href=\"gmlewis/gzip#Header\">Header</a>\n  w : <a href=\"gmlewis/io#Writer\">@gmlewis/io.Writer</a>\n  level : <a href=\"gmlewis/gzip#CompressionLevel\">CompressionLevel</a>\n  wrote_header : Bool\n  closed : Bool\n  buf : <a href=\"moonbitlang/core/array#Array\">Array</a>[Byte]\n  compressor : <a href=\"gmlewis/io#WriteCloser\">@gmlewis/io.WriteCloser</a>\n  digest : UInt\n  size : UInt\n  err : <a href=\"gmlewis/io#IOError\">@gmlewis/io.IOError</a>?\n}",
      "loc": { "line": 25, "column": 17 },
      "methods": [
        {
          "name": "close",
          "docstring": " close closes the [Writer] by flushing any unwritten data to the underlying\n [io.Writer] and writing the GZIP footer.\n It does not close the underlying [io.Writer].",
          "signature": "fn <a href=\"gmlewis/gzip#Writer\">Writer</a>::close(self : <a href=\"gmlewis/gzip#Writer\">Writer</a>) -> <a href=\"gmlewis/io#IOError\">@gmlewis/io.IOError</a>?",
          "loc": { "line": 260, "column": 8 }
        },
        {
          "name": "flush",
          "docstring": " flush flushes any pending compressed data to the underlying writer.\n\n It is useful mainly in compressed network protocols, to ensure that\n a remote reader has enough data to reconstruct a packet. Flush does\n not return until the data has been written. If the underlying\n writer returns an error, Flush returns that error.\n\n In the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH.",
          "signature": "fn <a href=\"gmlewis/gzip#Writer\">Writer</a>::flush(self : <a href=\"gmlewis/gzip#Writer\">Writer</a>) -> <a href=\"gmlewis/io#IOError\">@gmlewis/io.IOError</a>?",
          "loc": { "line": 241, "column": 8 }
        },
        {
          "name": "new",
          "docstring": " Writer::new returns a new [IOWriter] using the optional compression level\n (or `default_compression`).\n Writes to the returned writer are compressed and written to w.\n\n It is the caller's responsibility to call Close on the [Writer] when done.\n Writes may be buffered and not flushed until Close.\n\n Callers that wish to set the fields in Writer.Header must do so before\n the first call to Write, Flush, or Close.",
          "signature": "fn <a href=\"gmlewis/gzip#Writer\">Writer</a>::new(w : <a href=\"gmlewis/io#Writer\">@gmlewis/io.Writer</a>) -> <a href=\"gmlewis/gzip#Writer\">Writer</a>",
          "loc": { "line": 52, "column": 16 }
        },
        {
          "name": "write",
          "docstring": "",
          "signature": "fn <a href=\"gmlewis/gzip#Writer\">Writer</a>::write(self : <a href=\"gmlewis/gzip#Writer\">Writer</a>, p : <a href=\"gmlewis/io#Slice\">@gmlewis/io.Slice</a>[Byte]) -> (Int, <a href=\"gmlewis/io#IOError\">@gmlewis/io.IOError</a>?)",
          "loc": { "line": 142, "column": 8 }
        }
      ],
      "impls": []
    }
  ],
  "typealias": [],
  "values": [
    {
      "name": "best_speed",
      "docstring": "",
      "signature": "let best_speed : <a href=\"gmlewis/gzip#CompressionLevel\">CompressionLevel</a>",
      "loc": { "line": 20, "column": 9 }
    },
    {
      "name": "err_checksum",
      "docstring": "",
      "signature": "let err_checksum : <a href=\"gmlewis/io#IOError\">@gmlewis/io.IOError</a>",
      "loc": { "line": 43, "column": 9 }
    },
    {
      "name": "err_header",
      "docstring": "",
      "signature": "let err_header : <a href=\"gmlewis/io#IOError\">@gmlewis/io.IOError</a>",
      "loc": { "line": 47, "column": 9 }
    },
    {
      "name": "err_unexpected_eof",
      "docstring": "",
      "signature": "let err_unexpected_eof : <a href=\"gmlewis/io#IOError\">@gmlewis/io.IOError</a>",
      "loc": { "line": 50, "column": 9 }
    },
    {
      "name": "ioeof",
      "docstring": "",
      "signature": "let ioeof : <a href=\"gmlewis/io#IOError\">@gmlewis/io.IOError</a>",
      "loc": { "line": 53, "column": 9 }
    }
  ],
  "misc": []
}