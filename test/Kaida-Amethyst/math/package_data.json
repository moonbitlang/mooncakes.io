{
  "readme": "",
  "name": "Kaida-Amethyst/math",
  "traits": [],
  "types": [
    {
      "name": "RoundMode",
      "docstring": "",
      "signature": "pub(all) enum RoundMode {\n  FE_TONEAREST\n  FE_DOWNWARD\n  FE_UPWARD\n  FE_TOWARDZERO\n}",
      "loc": { "line": 1, "column": 15 },
      "methods": [],
      "impls": []
    }
  ],
  "typealias": [],
  "values": [
    {
      "name": "DIGITS",
      "docstring": "",
      "signature": "let DIGITS : UInt",
      "loc": { "line": 4, "column": 11 }
    },
    {
      "name": "DOUBLE_EPSILON",
      "docstring": " Epsilon is the minimum value that make double `1.0 + epsilon != 1.0`. 2.2204460492503131e-16",
      "signature": "let DOUBLE_EPSILON : Double",
      "loc": { "line": 19, "column": 11 }
    },
    {
      "name": "DOUBLE_MAX",
      "docstring": " The largest positive value that can be represented by a double. 1.7976931348623157E+308",
      "signature": "let DOUBLE_MAX : Double",
      "loc": { "line": 28, "column": 11 }
    },
    {
      "name": "DOUBLE_MAX_10_EXP",
      "docstring": " The maximum exponent a normalized double can have (base 10). 308",
      "signature": "let DOUBLE_MAX_10_EXP : Int",
      "loc": { "line": 40, "column": 11 }
    },
    {
      "name": "DOUBLE_MAX_EXP",
      "docstring": " The maximum exponent a normalized double can have (IEEE 754). 1024",
      "signature": "let DOUBLE_MAX_EXP : Int",
      "loc": { "line": 34, "column": 11 }
    },
    {
      "name": "DOUBLE_MIN",
      "docstring": " The smallest positive value that can be represented by a double. 2.2250738585072014E-308",
      "signature": "let DOUBLE_MIN : Double",
      "loc": { "line": 22, "column": 11 }
    },
    {
      "name": "DOUBLE_MIN_10_EXP",
      "docstring": " The minimum exponent a normalized double can have (base 10). -307",
      "signature": "let DOUBLE_MIN_10_EXP : Int",
      "loc": { "line": 37, "column": 11 }
    },
    {
      "name": "DOUBLE_MIN_EXP",
      "docstring": " The minimum exponent a normalized double can have (IEEE 754). -1021",
      "signature": "let DOUBLE_MIN_EXP : Int",
      "loc": { "line": 31, "column": 11 }
    },
    {
      "name": "DOUBLE_MIN_POSITIVE",
      "docstring": " The smallest positive value that can be represented by a double. 2.2250738585072014E-308",
      "signature": "let DOUBLE_MIN_POSITIVE : Double",
      "loc": { "line": 25, "column": 11 }
    },
    {
      "name": "E",
      "docstring": " Nature Exponent, 2.7182818284590452354",
      "signature": "let E : Double",
      "loc": { "line": 43, "column": 11 }
    },
    {
      "name": "GOLDEN_RATIO",
      "docstring": " golden ratio, 1.61803398874989484820",
      "signature": "let GOLDEN_RATIO : Double",
      "loc": { "line": 91, "column": 11 }
    },
    {
      "name": "INT64_MAX",
      "docstring": " INT64_MAX is the maximum value an `Int64` can represent. 9223372036854775807",
      "signature": "let INT64_MAX : Int64",
      "loc": { "line": 10, "column": 11 }
    },
    {
      "name": "INT_MAX",
      "docstring": " INT_MAX is the maximum value an `Int` can represent. 2147483647",
      "signature": "let INT_MAX : Int",
      "loc": { "line": 7, "column": 11 }
    },
    {
      "name": "INV_SQRT_PI",
      "docstring": " 1/sqrt(PI), 0.564189583547756286948",
      "signature": "let INV_SQRT_PI : Double",
      "loc": { "line": 61, "column": 11 }
    },
    {
      "name": "LN10",
      "docstring": " ln(10), 2.30258509299404568402",
      "signature": "let LN10 : Double",
      "loc": { "line": 82, "column": 11 }
    },
    {
      "name": "LN2",
      "docstring": " ln(2), 0.693147180559945309417",
      "signature": "let LN2 : Double",
      "loc": { "line": 79, "column": 11 }
    },
    {
      "name": "LOG10E",
      "docstring": " log10(e), 0.434294481903251827651",
      "signature": "let LOG10E : Double",
      "loc": { "line": 88, "column": 11 }
    },
    {
      "name": "LOG2E",
      "docstring": " log2(e), 1.44269504088896340736",
      "signature": "let LOG2E : Double",
      "loc": { "line": 85, "column": 11 }
    },
    {
      "name": "MANTISSA_DIGITS",
      "docstring": "",
      "signature": "let MANTISSA_DIGITS : UInt",
      "loc": { "line": 3, "column": 11 }
    },
    {
      "name": "ONE_OVER_PI",
      "docstring": " 1/PI, 0.318309886183790671538",
      "signature": "let ONE_OVER_PI : Double",
      "loc": { "line": 55, "column": 11 }
    },
    {
      "name": "PI",
      "docstring": " The ratio of the circumference of a circle to its diameter. 3.14159265358979323846",
      "signature": "let PI : Double",
      "loc": { "line": 46, "column": 11 }
    },
    {
      "name": "PI_OVER_2",
      "docstring": " PI/2, 1.57079632679489661923",
      "signature": "let PI_OVER_2 : Double",
      "loc": { "line": 49, "column": 11 }
    },
    {
      "name": "PI_OVER_4",
      "docstring": " PI/4, 0.785398163397448309616",
      "signature": "let PI_OVER_4 : Double",
      "loc": { "line": 52, "column": 11 }
    },
    {
      "name": "RADIX",
      "docstring": "",
      "signature": "let RADIX : UInt",
      "loc": { "line": 2, "column": 11 }
    },
    {
      "name": "SQRT1_OVER_2",
      "docstring": " 1/sqrt(2), 0.707106781186547524401",
      "signature": "let SQRT1_OVER_2 : Double",
      "loc": { "line": 70, "column": 11 }
    },
    {
      "name": "SQRT2",
      "docstring": " sqrt(2), 1.41421356237309504880",
      "signature": "let SQRT2 : Double",
      "loc": { "line": 67, "column": 11 }
    },
    {
      "name": "SQRT3",
      "docstring": " sqrt(3), 1.73205080756887729353",
      "signature": "let SQRT3 : Double",
      "loc": { "line": 73, "column": 11 }
    },
    {
      "name": "SQRT5",
      "docstring": " sqrt(5), 2.23606797749978969640",
      "signature": "let SQRT5 : Double",
      "loc": { "line": 76, "column": 11 }
    },
    {
      "name": "TWO_OVER_PI",
      "docstring": " 2/PI, 0.636619772367581343076",
      "signature": "let TWO_OVER_PI : Double",
      "loc": { "line": 58, "column": 11 }
    },
    {
      "name": "TWO_OVER_SQRTPI",
      "docstring": " 2/sqrt(PI), 1.12837916709551257390",
      "signature": "let TWO_OVER_SQRTPI : Double",
      "loc": { "line": 64, "column": 11 }
    },
    {
      "name": "UINT64_MAX",
      "docstring": " UINT64_MAX is the maximum value an `UInt64` can represent. 18446744073709551615",
      "signature": "let UINT64_MAX : UInt64",
      "loc": { "line": 16, "column": 11 }
    },
    {
      "name": "UINT_MAX",
      "docstring": " UINT_MAX is the maximum value an `UInt` can represent. 4294967295",
      "signature": "let UINT_MAX : UInt",
      "loc": { "line": 13, "column": 11 }
    },
    {
      "name": "acos",
      "docstring": " Compute arc cosine\n # Introduction\n\n Computes the principal value of the arc cosine of `x`.\n\n # Special cases\n\n 1. If `x` is NaN, a NaN is returned.\n 2. If |x| > 1, a NaN is returned with the invalid signal raised.\n\n # Accruacy\n\n 1 ulp (unit in the last place).",
      "signature": "fn acos(x : Double) -> Double",
      "loc": { "line": 29, "column": 8 }
    },
    {
      "name": "acosh",
      "docstring": " Return the inverse hyperbolic cosine of x.\n # Introduction\n\n Returns the inverse hyperbolic cosine of `x`, defined as the value `y` such that `x = cosh(y)`.\n\n # Special cases\n\n 1. If `x` is less than 1, the result is `NaN`.\n 2. If `x` is `NaN`, the result is `NaN`.\n\n # Accuracy\n\n 1 ulp (unit in the last place).",
      "signature": "fn acosh(x : Double) -> Double",
      "loc": { "line": 26, "column": 8 }
    },
    {
      "name": "asin",
      "docstring": " Compute arcsine of `x`",
      "signature": "fn asin(x : Double) -> Double",
      "loc": { "line": 104, "column": 8 }
    },
    {
      "name": "asinh",
      "docstring": " Compute the inverse hyperbolic sine of `x`.\n # Introduction\n\n Computes the inverse hyperbolic sine of `x`. The inverse hyperbolic sine is defined as:\n $$\\text{asinh}(x) = \\log(x + \\sqrt{x^2 + 1})$$\n\n # Accuracy\n\n 1 ulp (unit in the last place).",
      "signature": "fn asinh(x : Double) -> Double",
      "loc": { "line": 20, "column": 8 }
    },
    {
      "name": "atan",
      "docstring": " Compute arctangent of `x`",
      "signature": "fn atan(x : Double) -> Double",
      "loc": { "line": 164, "column": 8 }
    },
    {
      "name": "atan2",
      "docstring": " `atan2(y, x)` returns the angle whose tangent is `y/x`.\n # Special Cases:\n\n 1. `atan2((anything), NaN)` is NaN;\n 2. `atan2(NAN, (anything))` is NaN;\n 3. `atan2(+-0, +(anything but NaN))` is +-0;\n 4. `atan2(+-0, -(anything but NaN))` is +-pi;\n 5. `atan2(+-(anything but 0 and NaN), 0)` is +-pi/2;\n 6. `atan2(+-(anything but INF and NaN), +INF)` is +-0;\n 7. `atan2(+-(anything but INF and NaN), -INF)` is +-pi;\n 8. `atan2(+-INF,+INF)` is +-pi/4;\n 9. `atan2(+-INF,-INF)` is +-3pi/4;\n 10. `atan2(+-INF, (anything but,0,NaN, and INF))` is +-pi/2;",
      "signature": "fn atan2(y : Double, x : Double) -> Double",
      "loc": { "line": 124, "column": 8 }
    },
    {
      "name": "atanh",
      "docstring": " hyperbolic arctangent of ``x``.\n # Introduction:\n\n   atanh(x) returns the hyperbolic arctangent of x.\n\n # Special cases:\n\n 1. atanh(x) is NaN if |x| > 1 with signal;\n 2. atanh(NaN) is that NaN with no signal;\n 3. atanh(+-1) is +-INF with signal.\n\n # Accuracy:\n\n 1ulp (unit in the last place).",
      "signature": "fn atanh(x : Double) -> Double",
      "loc": { "line": 25, "column": 8 }
    },
    {
      "name": "cbrt",
      "docstring": " Return the cube root of `x`.\n # Introduction\n\n Return the cube root of `x`.\n\n # Special Cases\n\n 1. If `x` is NaN, the result is NaN.\n 2. If `x` is ±0, the result is ±0.\n\n # Accuracy\n\n 1 ulp (unit in the last place).",
      "signature": "fn cbrt(x : Double) -> Double",
      "loc": { "line": 14, "column": 8 }
    },
    {
      "name": "ceil",
      "docstring": " Return the smallest integral value that is not less than x",
      "signature": "fn ceil(x : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "clamp",
      "docstring": " Restrict a value to a certain interval unless it is NaN.\n\n Returns `max` if `x` is greater than `max`, and `min` if `self` is\n less than `min`. Otherwise this returns `self`.\n\n Note that this function returns NaN if the initial value was NaN as\n well.\n\n Note that if `min > max`, it will flip the `min` and `max` values.\n\n # Special cases\n\n If `x`, `min`, `max` one of them is NaN, the result is NaN.\n\n # Examples\n\n ```\n assert_eq!(clamp(-3.0, -2.0, 1.0), -2.0);\n assert_eq!(clamp(0.0, -2.0, 1.0), 0.0);\n assert_eq!(clamp(2.0, -2.0, 1.0), 1.0);\n ```",
      "signature": "fn clamp(x : Double, min : Double, max : Double) -> Double",
      "loc": { "line": 23, "column": 8 }
    },
    {
      "name": "cos",
      "docstring": " Compute cosine of double-precision floating-point number `x`",
      "signature": "fn cos(x : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "cosh",
      "docstring": " Compute hyperbolic cosine function of a double-precision floating point number.\n\n # Special Cases\n\n 1. cosh(x) is |x| if x is +INF, -INF, or NaN.\n 2. Only cosh(0)=1 is exact for finite x.",
      "signature": "fn cosh(x : Double) -> Double",
      "loc": { "line": 25, "column": 8 }
    },
    {
      "name": "cospi",
      "docstring": " Compute cos(pi*x) with high accuracy.\n # Introduction\n\n Compute cos(pi*x) with high accuracy.\n\n # Accuracy\n\n 49 ulp (1 bit error)",
      "signature": "fn cospi(x : Double) -> Double",
      "loc": { "line": 9, "column": 8 }
    },
    {
      "name": "digamma",
      "docstring": " digamma(x) computes the digamma function of x.",
      "signature": "fn digamma(x : Double) -> Double",
      "loc": { "line": 3, "column": 8 }
    },
    {
      "name": "div_euclid",
      "docstring": " Calculates Euclidean division, the matching method for `rem_euclid`.\n This computes the integer `n` such that\n `x = n * y + rem_euclid(x, y)`.\n In other words, the result is `x / y` rounded to the integer `n`\n such that `x >= n * y`.\n\n # Precision\n\n The result of this operation is guaranteed to be the rounded\n infinite-precision result.\n\n # Examples\n\n ```moonbit\n let a : Double = 7.0\n let b : Double = 4.0\n assert_eq!(div_euclid(a, b), 1.0)   // 7.0 >= 4.0 * 1.0\n assert_eq!(div_euclid(-a, b), -2.0) // -7.0 >= 4.0 * -2.0\n assert_eq!(div_euclid(a, -b), -2.0) // 7.0 >= -4.0 * -2.0\n assert_eq!(div_euclid(-a, -b), 1.0) // -7.0 >= -4.0 * 1.0\n ```",
      "signature": "fn div_euclid(x : Double, y : Double) -> Double",
      "loc": { "line": 22, "column": 8 }
    },
    {
      "name": "erf",
      "docstring": " Compute the error function of `x`.\n # Special Cases\n\n 1. erf(0) = 0\n 2. erf(inf) = 1\n 3. erf(-inf) = -1\n 4. erf(NaN) = NaN",
      "signature": "fn erf(x : Double) -> Double",
      "loc": { "line": 101, "column": 8 }
    },
    {
      "name": "erfc",
      "docstring": " Compute the error function of x\n # Special Cases\n\n 1. erfc(0) = 1\n 2. erfc(inf) = 0\n 3. erfc(-inf) = 2\n 4. erfc(NaN) = NaN",
      "signature": "fn erfc(x : Double) -> Double",
      "loc": { "line": 8, "column": 8 }
    },
    {
      "name": "erfcinv",
      "docstring": " Calculate the inverse complementary error function of the input argument.\n\n # Special Cases\n\n 1. erfcinv(+-0) = +Inf\n 2. erfcinv(2) = -inf\n 3. erfcinv(x) returns NaN for `x` outside [0, 2]\n 4. erfcinv(NaN) = NaN",
      "signature": "fn erfcinv(a : Double) -> Double",
      "loc": { "line": 9, "column": 8 }
    },
    {
      "name": "erfcx",
      "docstring": " erfcx(x) = exp(x^2) * erfc(x)",
      "signature": "fn erfcx(x : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "erfinv",
      "docstring": " erfinv(x) computes the inverse error function of x.\n\n Paper: Approximating the erfinv function, Mike Giles, Oxford:\n https://people.maths.ox.ac.uk/gilesm/codes/erfinv/gems.pdf",
      "signature": "fn erfinv(x : Double) -> Double",
      "loc": { "line": 6, "column": 8 }
    },
    {
      "name": "exp",
      "docstring": " Return exponent of x \n # Introduction:\n\n Compute exp(x)\n\n # Special cases:\n\n 1. exp(INF) is INF, exp(NaN) is NaN;\n 2. exp(-INF) is 0, and\n 3. for finite argument, only exp(0)=1 is exact.\n\n # Accuracy:\n \n   according to an error analysis, the error is always less than\n   1 ulp (unit in the last place).\n",
      "signature": "fn exp(input : Double) -> Double",
      "loc": { "line": 55, "column": 8 }
    },
    {
      "name": "exp10",
      "docstring": " Compute 10 raised to the power of x.",
      "signature": "fn exp10(x : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "exp2",
      "docstring": " Compute 2 raised to the power of x.",
      "signature": "fn exp2(x : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "expm1",
      "docstring": " Return exp(x)-1\n\n # Introduction\n\n Computes the exponential of `x` minus one.\n\n # Special cases\n\n 1. expm1(INF) is INF\n 2. expm1(NaN) is NaN\n 3. expm1(-INF) is -1\n 4. for finite argument, only expm1(0) is exact.\n 5. if x > 7.09782712893383973096e+02 then expm1(x) overflows\n\n # Accuracy\n\n According to an error analysis, the error is always less than\n 1 ulp (unit in the last place).",
      "signature": "fn expm1(x : Double) -> Double",
      "loc": { "line": 90, "column": 8 }
    },
    {
      "name": "fast_rsqrt",
      "docstring": " Inverse square root approximation using the fast inverse square root algorithm.",
      "signature": "fn fast_rsqrt(x : Float) -> Float",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "fdim",
      "docstring": " Compute the positive difference between `x` and `y`.\n\n Computes the positive difference between `x` and `y`, that is, if `x > y`, returns `x - y`, otherwise returns `0`.\n\n 1. fdim(`x`, `y`) returns `x - y` if `x > y`\n 2. fdim(`x`, `y`) returns `0` if `x <= y`\n 3. fdim(`x`, `y`) returns `NaN` if `x` or `y` is `NaN`",
      "signature": "fn fdim(x : Double, y : Double) -> Double",
      "loc": { "line": 8, "column": 8 }
    },
    {
      "name": "floor",
      "docstring": " Return the largest integral value less than or equal to x.",
      "signature": "fn floor(x : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "fma",
      "docstring": " fused multiply-add, fma(a, b, c) = a * b + c, but as a single operation with higher precision",
      "signature": "fn fma(a : Double, b : Double, c : Double) -> Double",
      "loc": { "line": 12, "column": 8 }
    },
    {
      "name": "fract",
      "docstring": " Return the fractional part of a number\n # Introduction\n\n Returns the fractional part of a number, which is the number without the integer part.\n\n # Example:\n\n ```moonbit\n let x = 3.14;\n let y = fract(x);\n assert!(y == 0.14);\n ```\n\n # Accuracy\n\n This function always returns the exact fractional part of the number.",
      "signature": "fn fract(x : Double) -> Double",
      "loc": { "line": 18, "column": 8 }
    },
    {
      "name": "frexp",
      "docstring": " Extract mantissa and exponent of a floating-point value.",
      "signature": "fn frexp(f : Double) -> (Double, Int)",
      "loc": { "line": 9, "column": 8 }
    },
    {
      "name": "gamma",
      "docstring": " Compute Gamma function",
      "signature": "fn gamma(x : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "gegenbauer",
      "docstring": " gegenbauer computes the Gegenbauer polynomial of degree n with parameter lambda at x.\n # Introduction\n\n Gegenbauer polynomials are orthogonal polynomials on the interval [-1,1] with weight function (1-x^2)^lambda.\n The formula for the Gegenbauer polynomial is\n\n \\[ C_n^{(\\lambda)}(x) = \\sum_{k=0}^n \\binom{n}{k} \\frac{\\Gamma(n+2\\lambda)}{\\Gamma(n-k+1)\\Gamma(2\\lambda+k)} \\left(\\frac{x-1}{2}\\right)^{n-k} \\]\n",
      "signature": "fn gegenbauer(n : UInt, lambda : Double, x : Double) -> Double",
      "loc": { "line": 9, "column": 8 }
    },
    {
      "name": "gegenbauer_derivative",
      "docstring": " gegenbauer_derivative is the derivative of the Gegenbauer polynomial of degree n with parameter lambda at x.",
      "signature": "fn gegenbauer_derivative(n : UInt, lambda : Double, x : Double, k : UInt) -> Double",
      "loc": { "line": 46, "column": 8 }
    },
    {
      "name": "gegenbauer_prime",
      "docstring": "",
      "signature": "fn gegenbauer_prime(n : UInt, lambda : Double, x : Double) -> Double",
      "loc": { "line": 63, "column": 8 }
    },
    {
      "name": "gelu",
      "docstring": " Computes the Gaussian Error Linear Unit (GELU) function.",
      "signature": "fn gelu(x : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "hermite",
      "docstring": " hermite(n, x) computes the nth Hermite polynomial at x.\n # Introduction\n\n hermite polynomials are a set of orthogonal polynomials that arise in the solution of the quantum harmonic oscillator.\n the formula for the nth hermite polynomial is given by:\n\n $$H_n(x) = (-1)^n * e^(x^2) * d^n/dx^n(e^(-x^2))$$\n",
      "signature": "fn hermite(n : UInt, x : Double) -> Double",
      "loc": { "line": 9, "column": 8 }
    },
    {
      "name": "hypot",
      "docstring": " Returns the square root of the sum of the squares of its arguments, hypot(x, y) = sqrt(x*x, y*y)\n # Introduction\n\n hypot return the square root of the sum of the squares of its arguments, the formula is:\n\n $$hypot(x) = \\sqrt{x^2 + y^2}$$\n\n # Special cases\n\n 1. If x or y is NaN, return NaN\n 2. If x or y is inf, return +inf\n\n # Accuracy\n\n 2 ulps (units in the last place)",
      "signature": "fn hypot(x : Double, y : Double) -> Double",
      "loc": { "line": 119, "column": 8 }
    },
    {
      "name": "ilogb",
      "docstring": " ilogb(x) returns the binary exponent of non-zero x",
      "signature": "fn ilogb(x : Double) -> Int",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "isfinite",
      "docstring": " Return double `x` is finite and is not nan\n\n if x is finite and not nan, return 1, otherwise return 0",
      "signature": "fn isfinite(x : Double) -> Bool",
      "loc": { "line": 4, "column": 8 }
    },
    {
      "name": "isinf",
      "docstring": " Return isinf(x) for double x\n\n if x is infinite, return 1, otherwise return 0",
      "signature": "fn isinf(x : Double) -> Bool",
      "loc": { "line": 4, "column": 8 }
    },
    {
      "name": "isnan",
      "docstring": " Return isnan(x) for double x\n\n if x is NaN, return true, otherwise return false",
      "signature": "fn isnan(x : Double) -> Bool",
      "loc": { "line": 5, "column": 8 }
    },
    {
      "name": "isninf",
      "docstring": " Return true if x is -inf",
      "signature": "fn isninf(x : Double) -> Bool",
      "loc": { "line": 14, "column": 8 }
    },
    {
      "name": "isnormal",
      "docstring": " Return true if x is a normal number, false otherwise.",
      "signature": "fn isnormal(x : Double) -> Bool",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "ispinf",
      "docstring": " Return true if x is +inf",
      "signature": "fn ispinf(x : Double) -> Bool",
      "loc": { "line": 9, "column": 8 }
    },
    {
      "name": "issubnormal",
      "docstring": " Return true if x is subnormal, false otherwise.",
      "signature": "fn issubnormal(x : Double) -> Bool",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "j0",
      "docstring": " Compute Bessel function of the first kind of order zero\n # Special cases:\n\n 1. j0(nan)= nan\n 2. j0(0) = 1\n 3. j0(inf) = 0",
      "signature": "fn j0(x : Double) -> Double",
      "loc": { "line": 33, "column": 8 }
    },
    {
      "name": "j1",
      "docstring": " Compute Bessel function of the first kind of order one.\n\n # Special Cases\n\n 1. `j1(x)` is NaN if `x` is NaN.\n 2. `j1(x)` is 0 if `x` is ±∞.\n 3. `j1(x)` is NaN if `x` is less than 0.",
      "signature": "fn j1(x : Double) -> Double",
      "loc": { "line": 26, "column": 8 }
    },
    {
      "name": "jn",
      "docstring": " Calculate the value of the Bessel function of the first kind of order n for the input argument.\n\n # Special Cases\n\n 1. jn(n, NaN) returns NaN.\n 2. jn(n, x) returns NaN for n < 0.\n 3. jn(n, x) returns NaN for x < 0.\n 4. jn(n, +-0) returns 0.\n\n # Notes\n\n 1. For n = 0, j0(x) is called.\n 2. For n = 1, j1(x) is called.",
      "signature": "fn jn(n : Int, x : Double) -> Double",
      "loc": { "line": 14, "column": 8 }
    },
    {
      "name": "ldexp",
      "docstring": " ldexp(x, exp) = x * 2^exp. It is equivalent to scalbn(x, exp).\n ldexp(x, exp) = x * 2^exp. It is equivalent to scalbn(x, exp).",
      "signature": "fn ldexp(x : Double, exp : Int) -> Double",
      "loc": { "line": 4, "column": 8 }
    },
    {
      "name": "lerp",
      "docstring": " Compute the linear interpolation between two values",
      "signature": "fn lerp(a : Double, b : Double, t : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "ln_1p",
      "docstring": " `ln_1p` is an alias for `log1p`",
      "signature": "fn ln_1p(x : Double) -> Double",
      "loc": { "line": 197, "column": 8 }
    },
    {
      "name": "log",
      "docstring": " Return the logrithm of x\n # Introduction:\n\n  Return the logrithm of x\n\n # Special cases:\n\n 1. log(x) is NaN with signal if x < 0 (including -INF).\n 2. log(+INF) is +INF.\n 3. log(0) is -INF with signal.\n\n # Accuracy:\n \n according to an error analysis, the error is always less than\n \n 1 ulp (unit in the last place).",
      "signature": "fn log(x : Double) -> Double",
      "loc": { "line": 55, "column": 8 }
    },
    {
      "name": "log10",
      "docstring": " Return the base 10 logarithm of `x`\n # Introduction\n\n Return the base 10 logarithm of `x`\n\n # Special cases\n\n `log10(x)` is `NaN` with signal if `x < 0`\n `log10(+INF)` is `+INF` with no signal\n `log10(0)` is `-INF` with signal\n `log10(NaN)` is that `NaN` with no signal\n `log10(10**N) = N` for `N=0,1,...,22`\n\n # Accuracy\n\n 1 ulp (unit in the last place)\n\n # Notes\n\n 1. To guarantee `log10(10**n)=n`, where `10**n` is normal, the rounding mode must set to Round-to-Nearest.\n 2. `[1/log(10)]` rounded to 53 bits has error  .198   ulps\n 3. `log10` is monotonic at all binary break points",
      "signature": "fn log10(x : Double) -> Double",
      "loc": { "line": 32, "column": 8 }
    },
    {
      "name": "log1p",
      "docstring": " ``log1p(x) = log(1+x)``\n # Introduction:\n\n  Compute log(1+x)\n\n # Special Cases\n\n 1. log1p(INF) is INF, log1p(NaN) is NaN;\n 2. log1p(-1) is -INF with signal;\n 3. log1p(NaN) is that NaN with no signal.\n\n # Accuracy:\n\n according to an error analysis, the error is always less than\n 1 ulp (unit in the last place).\n\n # Note\n\n Assuming log() return accurate answer, the following\n algorithm can be used to compute log1p(x) to within a few ULP:\n\n ```moonbit\n u = 1+x;\n if(u==1.0) return x ; else return log(u)*(x/(u-1.0));\n ```\n See HP-15C Advanced Functions Handbook, p.193.\n",
      "signature": "fn log1p(x : Double) -> Double",
      "loc": { "line": 94, "column": 8 }
    },
    {
      "name": "log2",
      "docstring": " Compute the base-2 logarithm of a number.",
      "signature": "fn log2(x : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "logaddexp",
      "docstring": " logaddexp(x1, x2) = log(exp(x1) + exp(x2))",
      "signature": "fn logaddexp(x1 : Double, x2 : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "logsumexp",
      "docstring": " Return the log of the sum of exponentials of the elements of the input array.\n # Introduction\n\n logsumexp(x) returns the natural logarithm of the sum of the exponentials of the elements of the input array x.\n See: https://nhigham.com/2021/01/05/what-is-the-log-sum-exp-function/\n to get more information.",
      "signature": "fn logsumexp(elements : <a href=\"moonbitlang/core/array#Array\">Array</a>[Double]) -> Double",
      "loc": { "line": 7, "column": 8 }
    },
    {
      "name": "nearbyint",
      "docstring": " Rounds the input floating-point number to the nearest integer according to the specified rounding mode.\n\n # Arguments\n - `x`: The floating-point number to be rounded.\n - `round_mode`: The rounding mode to use. Defaults to `FE_TONEAREST` (round to nearest, ties to even).\n\n # Rounding Modes\n - `FE_TONEAREST`: Rounds to the nearest integer. If the value is exactly halfway between two integers,\n   it rounds to the nearest even integer. This is the default behavior.\n - `FE_DOWNWARD`: Rounds towards negative infinity (equivalent to `floor`).\n - `FE_UPWARD`: Rounds towards positive infinity (equivalent to `ceil`).\n - `FE_TOWARDZERO`: Rounds towards zero (equivalent to `trunc`).\n\n # Returns\n The rounded floating-point number.\n\n # Example\n ```\n nearbyint(2.5) // Returns 2.0 (FE_TONEAREST mode)\n nearbyint(2.5, FE_DOWNWARD) // Returns 2.0 (FE_DOWNWARD mode)\n nearbyint(2.5, FE_UPWARD) // Returns 3.0 (FE_UPWARD mode)\n nearbyint(2.5, FE_TOWARDZERO) // Returns 2.0 (FE_TOWARDZERO mode)\n ```\n\n # Note\n\n It is equivalent to `rint` function. Note that it's different with C-like languages.",
      "signature": "fn nearbyint(x : Double, round_mode~ : <a href=\"Kaida-Amethyst/math#RoundMode\">RoundMode</a> = ..) -> Double",
      "loc": { "line": 35, "column": 8 }
    },
    {
      "name": "nextafter",
      "docstring": " Return next representable double-precision floating-point value after argument `x` in the direction of `y`.\n\n # Special cases\n\n 1. nextafter(x, y) = y if x equals y.\n 2. nextafter(x, y) = NaN if either x or y are NaN.",
      "signature": "fn nextafter(x : Double, y : Double) -> Double",
      "loc": { "line": 7, "column": 8 }
    },
    {
      "name": "norm",
      "docstring": " Calculate the square root of the sum of squares of any number of coordinates.\n Calculate the length of a vector p, dimension of which is passed as an argument without undue overflow or underflow.\n\n # Special Cases\n\n 1. If one of the coordinates is infinite, the result is infinite.\n 2. If one of the coordinates is NaN, the result is NaN.",
      "signature": "fn norm(vec : <a href=\"moonbitlang/core/array#Array\">Array</a>[Double]) -> Double",
      "loc": { "line": 8, "column": 8 }
    },
    {
      "name": "norm3d",
      "docstring": " Calculate the square root of the sum of squares of three coordinates of the argument.",
      "signature": "fn norm3d(a : Double, b : Double, c : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "norm4d",
      "docstring": " Calculate the square root of the sum of squares of four coordinates of the argument.",
      "signature": "fn norm4d(a : Double, b : Double, c : Double, d : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "normcdf",
      "docstring": " Calculate the standard normal cumulative distribution function.",
      "signature": "fn normcdf(x : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "normcdfinv",
      "docstring": " Calculate the inverse of the standard normal cumulative distribution function.",
      "signature": "fn normcdfinv(x : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "pow",
      "docstring": " Compute x pow of y, where x is a double and y is a double.\n # Introduction:\n\n   Compute `x**y` where `x` is a double and `y` is a double.\n\n # Special cases:\n\n 1.  (anything) ** 0  is 1  \n 2.  (anything) ** 1  is itself  \n 3.  (anything) ** NAN is NAN  \n 4.  NAN ** (anything except 0) is NAN  \n 5.  +-(|x| > 1) **  +INF is +INF  \n 6.  +-(|x| > 1) **  -INF is +0  \n 7.  +-(|x| < 1) **  +INF is +0  \n 8.  +-(|x| < 1) **  -INF is +INF  \n 9.  +-1         ** +-INF is NAN  \n 10. +0 ** (+anything except 0, NAN)               is +0  \n 11. -0 ** (+anything except 0, NAN, odd integer)  is +0  \n 12. +0 ** (-anything except 0, NAN)               is +INF  \n 13. -0 ** (-anything except 0, NAN, odd integer)  is +INF  \n 14. -0 ** (odd integer) = -( +0 ** (odd integer) )  \n 15. +INF ** (+anything except 0,NAN) is +INF  \n 16. +INF ** (-anything except 0,NAN) is +0  \n 17. -INF ** (anything)  = -0 ** (-anything)  \n 18. (-anything) ** (integer) is (-1)**(integer)*(+anything**integer)  \n 19. (-anything except 0 and inf) ** (non-integer) is NAN  \n\n# Accuracy:\n\n pow(x,y) returns x**y nearly rounded. In particular `pow(integer,integer)`\n always returns the correct integer provided it is \n representable.\n\n 2 ulp (units in the last place) are added for rounding.",
      "signature": "fn pow(base : Double, expon : Double) -> Double",
      "loc": { "line": 35, "column": 8 }
    },
    {
      "name": "powi",
      "docstring": " powi computes `x ** i` where x is a Double and i is an Int. It is an alias for `pown`.",
      "signature": "fn powi(x : Double, i : Int) -> Double",
      "loc": { "line": 28, "column": 8 }
    },
    {
      "name": "pown",
      "docstring": " pown computes `x ** n` where x is a Double and n is an Int.",
      "signature": "fn pown(x : Double, n : Int) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "rcbrt",
      "docstring": " Inverse cube root function",
      "signature": "fn rcbrt(x : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "rem_euclid",
      "docstring": " Calculates the least nonnegative remainder of `x (mod y)`.\n In particular, the return value `r` satisfies `0.0 <= r < abs(y)` in\n most cases. However, due to a floating point round-off error it can\n result in `r == abs(y)`, violating the mathematical definition, if\n `x` is much smaller than `abs(y)` in magnitude and `x < 0.0`.\n This result is not an element of the function's codomain, but it is the\n closest floating point number in the real numbers and thus fulfills the\n property `x == div_euclid(x, y) * y + rem_euclid(x, y)`\n approximately.\n\n # Precision\n\n The result of this operation is guaranteed to be the rounded\n infinite-precision result.\n\n # Examples\n\n ```\n let a: Double = 7.0;\n let b = 4.0;\n assert_eq!(rem_euclid(a, b), 3.0);\n assert_eq!(rem_euclid(-a, b), 1.0);\n assert_eq!(rem_euclid(a, -b), 3.0);\n assert_eq!(rem_euclid(-a, -b), 1.0);\n // limitation due to round-off error\n assert!(rem_euclid(EPSILON, 3.0) != 0.0);\n ```",
      "signature": "fn rem_euclid(x : Double, y : Double) -> Double",
      "loc": { "line": 30, "column": 8 }
    },
    {
      "name": "rhypot",
      "docstring": " Inverse of the hypotenuse of a right triangle",
      "signature": "fn rhypot(x : Double, y : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "rint",
      "docstring": " Rounds the input floating-point number to the nearest integer according to the specified rounding mode.\n\n # Arguments\n - `x`: The floating-point number to be rounded.\n - `round_mode`: The rounding mode to use. Defaults to `FE_TONEAREST` (round to nearest, ties to even).\n\n # Rounding Modes\n - `FE_TONEAREST`: Rounds to the nearest integer. If the value is exactly halfway between two integers,\n   it rounds to the nearest even integer. This is the default behavior.\n - `FE_DOWNWARD`: Rounds towards negative infinity (equivalent to `floor`).\n - `FE_UPWARD`: Rounds towards positive infinity (equivalent to `ceil`).\n - `FE_TOWARDZERO`: Rounds towards zero (equivalent to `trunc`).\n\n # Returns\n The rounded floating-point number.\n\n # Example\n ```\n rint(2.5) // Returns 2.0 (FE_TONEAREST mode)\n rint(2.5, FE_DOWNWARD) // Returns 2.0 (FE_DOWNWARD mode)\n rint(2.5, FE_UPWARD) // Returns 3.0 (FE_UPWARD mode)\n rint(2.5, FE_TOWARDZERO) // Returns 2.0 (FE_TOWARDZERO mode)\n ```\n\n # Note\n\n It is equivalent to `nearbyint` function. Note that it's different with C-like languages.",
      "signature": "fn rint(x : Double, round_mode~ : <a href=\"Kaida-Amethyst/math#RoundMode\">RoundMode</a> = ..) -> Double",
      "loc": { "line": 28, "column": 8 }
    },
    {
      "name": "rnorm",
      "docstring": " Calculate the reciprocal of square root of the sum of squares of any number of coordinates.",
      "signature": "fn rnorm(vec : <a href=\"moonbitlang/core/array#Array\">Array</a>[Double]) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "rnorm3d",
      "docstring": " Calculate one over the square root of the sum of squares of three coordinates.",
      "signature": "fn rnorm3d(a : Double, b : Double, c : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "rnorm4d",
      "docstring": " Calculate one over the square root of the sum of squares of four coordinates.",
      "signature": "fn rnorm4d(a : Double, b : Double, c : Double, d : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "round",
      "docstring": " Return the nearest integer value to `x`.",
      "signature": "fn round(x : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "roundeven",
      "docstring": " roundeven is a function that rounds a number to the nearest even integer.\n\n # Special Cases\n\n 1. roundeven(NaN) = NaN\n 2. roundeven(±∞) = ±∞\n\n # Examples\n\n ```\n let x = 1.4; assert_eq!(roundeven(x), 1.0);\n let x = 1.5; assert_eq!(roundeven(x), 2.0);\n let x = 1.6; assert_eq!(roundeven(x), 2.0);\n let x = 2.4; assert_eq!(roundeven(x), 2.0);\n let x = 2.5; assert_eq!(roundeven(x), 2.0);\n let x = 2.6; assert_eq!(roundeven(x), 3.0);\n ```",
      "signature": "fn roundeven(x : Double) -> Double",
      "loc": { "line": 18, "column": 8 }
    },
    {
      "name": "rsqrt",
      "docstring": " Inverse square root of a number",
      "signature": "fn rsqrt(x : Double) -> Double",
      "loc": { "line": 4, "column": 8 }
    },
    {
      "name": "scalbn",
      "docstring": " Compute x * 2 **n where x is a double and n is an integer.\n # Introcution:\n\n Compute x * 2 **n without computing 2 ** n.\n\n # Accruacy:\n\n 1 ulp (unit in the last place).",
      "signature": "fn scalbn(input : Double, n : Int) -> Double",
      "loc": { "line": 9, "column": 8 }
    },
    {
      "name": "signum",
      "docstring": " Return a number that represents the sign of the argument.\n\n - `1.0` if the argument is positive, `+0.0` or `+Inf`\n - `-1.0` if the argument is negative, `-0.0` or `-Inf`\n - `NaN` if the argument is `NaN`",
      "signature": "fn signum(x : Double) -> Double",
      "loc": { "line": 7, "column": 8 }
    },
    {
      "name": "sin",
      "docstring": " Compute sine of double-precision floating-point number `x`.",
      "signature": "fn sin(x : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "sincos",
      "docstring": " Compute the sine and cosine of a number simultaneously",
      "signature": "fn sincos(x : Double) -> (Double, Double)",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "sincospi",
      "docstring": " Compute the sine and cosine of a number multiplied by pi simultaneously",
      "signature": "fn sincospi(x : Double) -> (Double, Double)",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "sinh",
      "docstring": " Compute hyperbolic sine function of a double-precision floating point number.\n\n # Special Cases\n\n 1. sinh(x) is |x| if x is +INF, -INF, or NaN.\n 2. Only sinh(0)=0 is exact for finite x.",
      "signature": "fn sinh(x : Double) -> Double",
      "loc": { "line": 24, "column": 8 }
    },
    {
      "name": "sinpi",
      "docstring": " Compute sin(pi*x) with high accuracy.\n # Introduction\n\n Compute sin(pi*x) with high accuracy.\n\n # Accuracy\n\n 1 ulp (1 bit error)",
      "signature": "fn sinpi(x : Double) -> Double",
      "loc": { "line": 9, "column": 8 }
    },
    {
      "name": "sqrt",
      "docstring": " Compute Square Root of a number",
      "signature": "fn sqrt(x : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "sqrt1pm1",
      "docstring": " sqrt1pm1(x) compute sqrt(1 + x) - 1 with higher accuracy than the naive formula",
      "signature": "fn sqrt1pm1(x : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "tan",
      "docstring": " Compute the tangent of double-precision floating-point number `x`.",
      "signature": "fn tan(x : Double) -> Double",
      "loc": { "line": 11, "column": 8 }
    },
    {
      "name": "tanh",
      "docstring": " Compute hyperbolic tangent function of a double-precision floating point number.\n\n # Special Cases\n\n 1. tanh(x) is x if x is NaN.\n 2. tanh(x) is 1 if x is +INF.",
      "signature": "fn tanh(x : Double) -> Double",
      "loc": { "line": 30, "column": 8 }
    },
    {
      "name": "to_degrees",
      "docstring": " Converts radians to degrees.",
      "signature": "fn to_degrees(x : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "to_radians",
      "docstring": " Converts degrees to radians.",
      "signature": "fn to_radians(x : Double) -> Double",
      "loc": { "line": 3, "column": 8 }
    },
    {
      "name": "trunc",
      "docstring": " Return the integral part of a floating point number",
      "signature": "fn trunc(x : Double) -> Double",
      "loc": { "line": 2, "column": 8 }
    },
    {
      "name": "y0",
      "docstring": " Compute Bessel function of the second kind of order zero\n # Special Cases\n\n 1. y0(nan) is nan\n 2. y0(0) is 0\n 3. y0(inf) is 0",
      "signature": "fn y0(x : Double) -> Double",
      "loc": { "line": 25, "column": 8 }
    },
    {
      "name": "y1",
      "docstring": " Compute Bessel function of the second kind of order one.\n\n # Special Cases\n\n 1. `y1(x)` is NaN if `x` is NaN.\n 2. `y1(x)` is 0 if `x` is ±∞.\n 3. `y1(x)` is NaN if `x` is less than 0.",
      "signature": "fn y1(x : Double) -> Double",
      "loc": { "line": 26, "column": 8 }
    },
    {
      "name": "yn",
      "docstring": " Calculate the value of the Bessel function of the second kind of order n for the input argument.\n\n # Special Cases\n\n 1. yn(n, x) returns NaN for n < 0.\n 2. yn(n, +-0) returns NaN.\n 3. yn(n, x) returns NaN for x < 0.\n 4. yn(n, +inf) returns +0.\n 5. yn(n, NaN) returns NaN.\n\n # Note\n\n 1. For n = 0, y0(x) is called.\n 2. For n = 1, y1(x) is called.",
      "signature": "fn yn(n : Int, x : Double) -> Double",
      "loc": { "line": 15, "column": 8 }
    },
    {
      "name": "zeta",
      "docstring": "",
      "signature": "fn zeta(x : Double, y : Double) -> Double",
      "loc": { "line": 3, "column": 8 }
    }
  ],
  "misc": []
}