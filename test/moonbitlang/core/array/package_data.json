{
  "readme": "",
  "name": "moonbitlang/core/array",
  "traits": [],
  "types": [],
  "typealias": [],
  "values": [],
  "misc": [
    {
      "name": "Array",
      "impls": [
        {
          "name": "arbitrary",
          "docstring": "",
          "signature": "impl <a href=\"moonbitlang/core/quickcheck#Arbitrary\">@moonbitlang/core/quickcheck.Arbitrary</a> for <a href=\"moonbitlang/core/array#Array\">Array</a> with arbitrary[X : <a href=\"moonbitlang/core/quickcheck#Arbitrary\">@moonbitlang/core/quickcheck.Arbitrary</a>](size : Int, rs : <a href=\"moonbitlang/core/quickcheck/splitmix#RandomState\">@moonbitlang/core/quickcheck/splitmix.RandomState</a>) -> <a href=\"moonbitlang/core/array#Array\">Array</a>[X]",
          "loc": { "line": 136, "column": 77 }
        }
      ],
      "methods": [
        {
          "name": "arbitrary",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/array#Array\">Array</a>::arbitrary[X : <a href=\"moonbitlang/core/quickcheck#Arbitrary\">@moonbitlang/core/quickcheck.Arbitrary</a>](size : Int, rs : <a href=\"moonbitlang/core/quickcheck/splitmix#RandomState\">@moonbitlang/core/quickcheck/splitmix.RandomState</a>) -> <a href=\"moonbitlang/core/array#Array\">Array</a>[X]",
          "loc": { "line": 136, "column": 77 }
        },
        {
          "name": "copy",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/array#Array\">Array</a>::copy[T](self : <a href=\"moonbitlang/core/array#Array\">Array</a>[T]) -> <a href=\"moonbitlang/core/array#Array\">Array</a>[T]",
          "loc": { "line": 16, "column": 8 }
        },
        {
          "name": "from_iter",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/array#Array\">Array</a>::from_iter[T](iter : <a href=\"moonbitlang/core/builtin#Iter\">Iter</a>[T]) -> <a href=\"moonbitlang/core/array#Array\">Array</a>[T]",
          "loc": { "line": 16, "column": 15 }
        },
        {
          "name": "last",
          "docstring": "\n Returns the last element of the array.",
          "signature": "fn <a href=\"moonbitlang/core/array#Array\">Array</a>::last[A](self : <a href=\"moonbitlang/core/array#Array\">Array</a>[A]) -> A?",
          "loc": { "line": 128, "column": 8 }
        },
        {
          "name": "makei",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/array#Array\">Array</a>::makei[T](length : Int, value : (Int) -> T) -> <a href=\"moonbitlang/core/array#Array\">Array</a>[T]",
          "loc": { "line": 40, "column": 15 }
        },
        {
          "name": "map_option",
          "docstring": "\n Returns a new array containing the elements of the original array that satisfy the given predicate.\n \n # Arguments\n \n * `self` - The array to filter.\n * `f` - The predicate function.\n \n # Returns\n ",
          "signature": "fn <a href=\"moonbitlang/core/array#Array\">Array</a>::map_option[A, B](self : <a href=\"moonbitlang/core/array#Array\">Array</a>[A], f : (A) -> B?) -> <a href=\"moonbitlang/core/array#Array\">Array</a>[B]",
          "loc": { "line": 114, "column": 8 }
        },
        {
          "name": "push_iter",
          "docstring": "\n Adds all elements from an iterator to the end of the array.\n\n This function iterates over each element in the provided iterator\n and adds them to the array using the `push` method.\n\n # Example\n ```\n let u = [1, 2, 3]\n let v = [4, 5, 6]\n u.push_iter(v.iter())\n assert_eq!(u, [1, 2, 3, 4, 5, 6])\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#Array\">Array</a>::push_iter[T](self : <a href=\"moonbitlang/core/array#Array\">Array</a>[T], iter : <a href=\"moonbitlang/core/builtin#Iter\">Iter</a>[T]) -> Unit",
          "loc": { "line": 33, "column": 8 }
        },
        {
          "name": "shuffle",
          "docstring": "\n Shuffle the array using Knuth shuffle\n \n To use this function, you need to provide a rand function, which takes an integer as it upper bound\n and returns an integer.\n *rand n* is expected to returns a uniformly distribution integer between 0 and n - 1\n # Example\n \n ```\n let arr = [1, 2, 3, 4, 5]\n fn rand(upper : Int) -> Int {\n   let rng = @random.new()\n   rng.int(limit=upper)\n }\n let _shuffled = Array::shuffle(arr, rand=rand)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#Array\">Array</a>::shuffle[T](arr : <a href=\"moonbitlang/core/array#Array\">Array</a>[T], rand~ : (Int) -> Int) -> <a href=\"moonbitlang/core/array#Array\">Array</a>[T]",
          "loc": { "line": 98, "column": 15 }
        },
        {
          "name": "shuffle_in_place",
          "docstring": "\n Shuffle the array using Knuth shuffle\n \n To use this function, you need to provide a rand function, which takes an integer as it upper bound\n and returns an integer.\n *rand n* is expected to returns a uniformly distribution integer between 0 and n - 1\n # Example\n \n ```\n let arr = [1, 2, 3, 4, 5]\n fn rand(upper : Int) -> Int {\n   let rng = @random.new()\n   rng.int(limit=upper)\n }\n Array::shuffle_in_place(arr, rand=rand)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#Array\">Array</a>::shuffle_in_place[T](arr : <a href=\"moonbitlang/core/array#Array\">Array</a>[T], rand~ : (Int) -> Int) -> Unit",
          "loc": { "line": 68, "column": 15 }
        },
        {
          "name": "sort",
          "docstring": "\n Sorts the array in place.\n \n It's an in-place, unstable sort(it will reorder equal elements). The time complexity is O(n log n) in the worst case.\n \n # Example\n \n ```\n let arr = [5, 4, 3, 2, 1]\n arr.sort()\n assert_eq!(arr, [1, 2, 3, 4, 5])\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#Array\">Array</a>::sort[T : <a href=\"moonbitlang/core/builtin#Compare\">Compare</a> + <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/array#Array\">Array</a>[T]) -> Unit",
          "loc": { "line": 27, "column": 8 }
        },
        {
          "name": "sort_by",
          "docstring": "\n Sorts the array with a custom comparison function.\n \n It's an in-place, unstable sort(it will reorder equal elements). The time complexity is O(n log n) in the worst case.\n \n # Example\n \n ```\n let arr = [5, 3, 2, 4, 1]\n arr.sort_by(fn (a, b) { a - b })\n assert_eq!(arr, [1, 2, 3, 4, 5])\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#Array\">Array</a>::sort_by[T](self : <a href=\"moonbitlang/core/array#Array\">Array</a>[T], cmp : (T, T) -> Int) -> Unit",
          "loc": { "line": 48, "column": 8 }
        },
        {
          "name": "sort_by_key",
          "docstring": "\n Sorts the array with a key extraction function.\n \n It's an in-place, unstable sort(it will reorder equal elements). The time complexity is O(n log n) in the worst case.\n \n # Example\n \n ```\n let arr = [5, 3, 2, 4, 1]\n arr.sort_by_key(fn (x) {-x})\n assert_eq!(arr, [5, 4, 3, 2, 1])\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#Array\">Array</a>::sort_by_key[T, K : <a href=\"moonbitlang/core/builtin#Compare\">Compare</a> + <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/array#Array\">Array</a>[T], map : (T) -> K) -> Unit",
          "loc": { "line": 27, "column": 8 }
        }
      ]
    },
    {
      "name": "ArrayView",
      "impls": [],
      "methods": [
        {
          "name": "all",
          "docstring": "\n Checks if all elements in the array view match the condition.\n \n # Example\n \n ```\n let v = [1, 4, 6, 8, 9]\n assert_false!(v[:].all(fn(elem) { elem % 2 == 0 }))\n assert_true!(v[1:4].all(fn(elem) { elem % 2 == 0 }))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#ArrayView\">ArrayView</a>::all[T](self : <a href=\"moonbitlang/core/array#ArrayView\">ArrayView</a>[T], f : (T) -> Bool) -> Bool",
          "loc": { "line": 58, "column": 8 }
        },
        {
          "name": "any",
          "docstring": "\n Check if any of the elements in the array view match the condition.\n\n # Example\n\n ```\n let v = [1, 2, 3, 4, 5][:]\n assert_true!(v.any(fn(ele) { ele < 6 }))\n assert_false!(v.any(fn(ele) { ele < 1 }))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#ArrayView\">ArrayView</a>::any[T](self : <a href=\"moonbitlang/core/array#ArrayView\">ArrayView</a>[T], f : (T) -> Bool) -> Bool",
          "loc": { "line": 77, "column": 8 }
        },
        {
          "name": "contains",
          "docstring": "\n Checks if the array view contains an element.\n\n # Example\n ```\n let v = [3, 4, 5][:]\n assert_true!(v.contains(3))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#ArrayView\">ArrayView</a>::contains[T : <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/array#ArrayView\">ArrayView</a>[T], value : T) -> Bool",
          "loc": { "line": 94, "column": 8 }
        },
        {
          "name": "each",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/array#ArrayView\">ArrayView</a>::each[T](self : <a href=\"moonbitlang/core/array#ArrayView\">ArrayView</a>[T], f : (T) -> Unit) -> Unit",
          "loc": { "line": 25, "column": 8 }
        },
        {
          "name": "eachi",
          "docstring": "\n Iterates over the elements of the array view with index.\n\n # Example\n \n ```\n let v = [3, 4, 5][:]\n let mut sum = 0\n v.eachi(fn (i, x) { sum = sum + x + i })\n assert_eq!(sum, 15)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#ArrayView\">ArrayView</a>::eachi[T](self : <a href=\"moonbitlang/core/array#ArrayView\">ArrayView</a>[T], f : (Int, T) -> Unit) -> Unit",
          "loc": { "line": 42, "column": 8 }
        },
        {
          "name": "rev_inplace",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/array#ArrayView\">ArrayView</a>::rev_inplace[T](self : <a href=\"moonbitlang/core/array#ArrayView\">ArrayView</a>[T]) -> Unit",
          "loc": { "line": 16, "column": 8 }
        }
      ]
    },
    {
      "name": "FixedArray",
      "impls": [
        {
          "name": "arbitrary",
          "docstring": "",
          "signature": "impl <a href=\"moonbitlang/core/quickcheck#Arbitrary\">@moonbitlang/core/quickcheck.Arbitrary</a> for <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a> with arbitrary[X : <a href=\"moonbitlang/core/quickcheck#Arbitrary\">@moonbitlang/core/quickcheck.Arbitrary</a>](size : Int, rs : <a href=\"moonbitlang/core/quickcheck/splitmix#RandomState\">@moonbitlang/core/quickcheck/splitmix.RandomState</a>) -> <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[X]",
          "loc": { "line": 1002, "column": 82 }
        }
      ],
      "methods": [
        {
          "name": "all",
          "docstring": "\n Check if all the elements in the array match the condition.\n\n # Example\n\n ```\n let arr: FixedArray[Int] = [1, 2, 3, 4, 5]\n assert_true!(arr.all(fn(ele) { ele < 6 }))\n assert_false!(arr.all(fn(ele) { ele < 5 }))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::all[T](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T], f : (T) -> Bool) -> Bool",
          "loc": { "line": 575, "column": 8 }
        },
        {
          "name": "any",
          "docstring": "\n Check if any of the elements in the array match the condition.\n\n # Example\n\n ```\n let arr: FixedArray[Int] = [1, 2, 3, 4, 5]\n assert_true!(arr.any(fn(ele) { ele < 6 }))\n assert_true!(arr.any(fn(ele) { ele < 5 }))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::any[T](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T], f : (T) -> Bool) -> Bool",
          "loc": { "line": 610, "column": 8 }
        },
        {
          "name": "arbitrary",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::arbitrary[X : <a href=\"moonbitlang/core/quickcheck#Arbitrary\">@moonbitlang/core/quickcheck.Arbitrary</a>](size : Int, rs : <a href=\"moonbitlang/core/quickcheck/splitmix#RandomState\">@moonbitlang/core/quickcheck/splitmix.RandomState</a>) -> <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[X]",
          "loc": { "line": 1002, "column": 82 }
        },
        {
          "name": "contains",
          "docstring": "\n Checks if the array contains an element.\n\n # Example\n ```\n let arr: FixedArray[Int] = [3, 4, 5]\n assert_true!(arr.contains(3))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::contains[T : <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T], value : T) -> Bool",
          "loc": { "line": 694, "column": 8 }
        },
        {
          "name": "copy",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::copy[T](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T]) -> <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T]",
          "loc": { "line": 16, "column": 8 }
        },
        {
          "name": "each",
          "docstring": "\n Iterates over each element.\n\n # Arguments\n\n - `self`: The array to iterate over.\n - `f`: The function to apply to each element.\n\n # Example\n\n ```\n let arr = []\n [1, 2, 3, 4, 5].each(fn(x){ arr.push(x) })\n assert_eq!(arr, [1, 2, 3, 4, 5])\n ```\n TODO: change the intrinsic to match the function name\n @intrinsic %fixedarray.iter",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::each[T](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T], f : (T) -> Unit) -> Unit",
          "loc": { "line": 32, "column": 8 }
        },
        {
          "name": "eachi",
          "docstring": "\n Iterates over the array with index.\n\n # Arguments\n\n - `self`: The array to iterate over.\n - `f`: A function that takes an `Int` representing the index and a `T` representing the element of the array, and returns `Unit`.\n\n # Example\n\n ```\n let arr = []\n [1, 2, 3, 4, 5].eachi(fn(index, elem){\n   arr.push((index, elem))\n })\n assert_eq!(arr, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)])\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::eachi[T](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T], f : (Int, T) -> Unit) -> Unit",
          "loc": { "line": 82, "column": 8 }
        },
        {
          "name": "ends_with",
          "docstring": "\n Check if the array ends with a given suffix.\n\n # Example\n ```\n let v: FixedArray[Int] = [3, 4, 5]\n assert_true!(v.ends_with([5]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::ends_with[T : <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T], suffix : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T]) -> Bool",
          "loc": { "line": 776, "column": 8 }
        },
        {
          "name": "fold",
          "docstring": "\n Fold out values from an array according to certain rules.\n\n # Example\n ```\n let sum = [1, 2, 3, 4, 5].fold(init=0, fn { sum, elem => sum + elem })\n assert_eq!(sum, 15)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::fold[A, B](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[A], init~ : B, f : (B, A) -> B) -> B",
          "loc": { "line": 343, "column": 8 }
        },
        {
          "name": "fold_left",
          "docstring": "\n Fold out values from an array according to certain rules.\n\n # Example\n ```\n let sum = [1, 2, 3, 4, 5].fold(init=0, fn { sum, elem => sum + elem })\n assert_eq!(sum, 15)\n ```\n @alert deprecated \"Use `fold` instead\"",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::fold_left[T, U](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T], f : (U, T) -> U, init~ : U) -> U",
          "loc": { "line": 49, "column": 8 }
        },
        {
          "name": "fold_lefti",
          "docstring": "\n Fold out values from an array according to certain rules with index.\n\n # Example\n ```\n let sum = [1, 2, 3, 4, 5].foldi(init=0, fn { index, sum, _elem => sum + index })\n assert_eq!(sum, 10)\n ```\n @alert deprecated \"Use `foldi` instead\"",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::fold_lefti[T, U](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T], f : (Int, U, T) -> U, init~ : U) -> U",
          "loc": { "line": 75, "column": 8 }
        },
        {
          "name": "fold_right",
          "docstring": "\n Fold out values from an array according to certain rules in reversed turn.\n\n # Example\n ```\n let sum = [1, 2, 3, 4, 5].rev_fold(init=0, fn { sum, elem => sum + elem })\n assert_eq!(sum, 15)\n ```\n @alert deprecated \"Use `rev_fold` instead\"",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::fold_right[T, U](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T], f : (U, T) -> U, init~ : U) -> U",
          "loc": { "line": 62, "column": 8 }
        },
        {
          "name": "fold_righti",
          "docstring": "\n Fold out values from an array according to certain rules in reversed turn with index.\n\n # Example\n ```\n let sum = [1, 2, 3, 4, 5].rev_foldi(init=0, fn { index, sum, _elem => sum + index })\n assert_eq!(sum, 10)\n ```\n @alert deprecated \"Use `rev_foldi` instead\"",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::fold_righti[T, U](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T], f : (Int, U, T) -> U, init~ : U) -> U",
          "loc": { "line": 92, "column": 8 }
        },
        {
          "name": "foldi",
          "docstring": "\n Fold out values from an array according to certain rules with index.\n\n # Example\n ```\n let sum = [1, 2, 3, 4, 5].foldi(init=0, fn { index, sum, _elem => sum + index })\n assert_eq!(sum, 10)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::foldi[A, B](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[A], init~ : B, f : (Int, B, A) -> B) -> B",
          "loc": { "line": 399, "column": 8 }
        },
        {
          "name": "from_array",
          "docstring": "\n Create a new array with given values.",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::from_array[T](array : <a href=\"moonbitlang/core/array#Array\">Array</a>[T]) -> <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T]",
          "loc": { "line": 326, "column": 20 }
        },
        {
          "name": "from_iter",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::from_iter[T](iter : <a href=\"moonbitlang/core/builtin#Iter\">Iter</a>[T]) -> <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T]",
          "loc": { "line": 961, "column": 20 }
        },
        {
          "name": "is_sorted",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::is_sorted[T : <a href=\"moonbitlang/core/builtin#Compare\">Compare</a> + <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](arr : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T]) -> Bool",
          "loc": { "line": 505, "column": 20 }
        },
        {
          "name": "last",
          "docstring": "\n Returns the last element of the fixed array.",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::last[A](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[A]) -> A?",
          "loc": { "line": 967, "column": 20 }
        },
        {
          "name": "makei",
          "docstring": "\n Create a new array. Values are built from indexes.",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::makei[T](length : Int, value : (Int) -> T) -> <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T]",
          "loc": { "line": 300, "column": 20 }
        },
        {
          "name": "map",
          "docstring": "\n Applies a function to each element of the array and returns a new array with the results.\n\n # Example\n\n ```\n let arr = [1, 2, 3, 4, 5]\n let doubled = arr.map(fn(x){ x * 2 })\n assert_eq!(doubled, [2, 4, 6, 8, 10])\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::map[T, U](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T], f : (T) -> U) -> <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[U]",
          "loc": { "line": 232, "column": 8 }
        },
        {
          "name": "mapi",
          "docstring": "\n Maps a function over the elements of the arr with index.\n\n # Example\n ```\n let arr = [3, 4, 5]\n let added = arr.mapi(fn (i, x) { x + i })\n assert_eq!(added, [3, 5, 7])\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::mapi[T, U](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T], f : (Int, T) -> U) -> <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[U]",
          "loc": { "line": 263, "column": 8 }
        },
        {
          "name": "new",
          "docstring": "\n Create a new array. Values are lazily built.\n @alert deprecated \"Use `FixedArray::makei` instead\"",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::new[T](length : Int, value : () -> T) -> <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T]",
          "loc": { "line": 18, "column": 20 }
        },
        {
          "name": "new_with_index",
          "docstring": "\n Create a new array. Values are built from indexes.\n @alert deprecated \"Use `FixedArray::makei` instead\"",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::new_with_index[T](length : Int, value : (Int) -> T) -> <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T]",
          "loc": { "line": 33, "column": 20 }
        },
        {
          "name": "op_add",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::op_add[T](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T], other : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T]) -> <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T]",
          "loc": { "line": 894, "column": 8 }
        },
        {
          "name": "op_equal",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::op_equal[T : <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T], that : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T]) -> Bool",
          "loc": { "line": 819, "column": 8 }
        },
        {
          "name": "rev",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::rev[T](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T]) -> <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T]",
          "loc": { "line": 468, "column": 8 }
        },
        {
          "name": "rev_each",
          "docstring": "\n Iterates over each element in reversed turn.\n\n # Arguments\n\n - `self`: The array to iterate over.\n - `f`: The function to apply to each element.\n\n # Example\n\n ```\n let arr = []\n [1, 2, 3, 4, 5].rev_each(fn(x){ arr.push(x) })\n assert_eq!(arr, [5, 4, 3, 2, 1])\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::rev_each[T](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T], f : (T) -> Unit) -> Unit",
          "loc": { "line": 130, "column": 8 }
        },
        {
          "name": "rev_eachi",
          "docstring": "\n Iterates over the array with index in reversed turn.\n\n # Arguments\n\n - `self`: The array to iterate over.\n - `f`: A function that takes an `Int` representing the index and a `T` representing the element of the array, and returns `Unit`.\n\n # Example\n\n ```\n let arr = []\n [1, 2, 3, 4, 5].rev_eachi(fn(index, elem){\n   arr.push((index, elem))\n })\n assert_eq!(arr, [(0, 5), (1, 4), (2, 3), (3, 2), (4, 1)])\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::rev_eachi[T](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T], f : (Int, T) -> Unit) -> Unit",
          "loc": { "line": 180, "column": 8 }
        },
        {
          "name": "rev_fold",
          "docstring": "\n Fold out values from an array according to certain rules in reversed turn.\n\n # Example\n ```\n let sum = [1, 2, 3, 4, 5].rev_fold(init=0, fn { sum, elem => sum + elem })\n assert_eq!(sum, 15)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::rev_fold[A, B](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[A], init~ : B, f : (B, A) -> B) -> B",
          "loc": { "line": 370, "column": 8 }
        },
        {
          "name": "rev_foldi",
          "docstring": "\n Fold out values from an array according to certain rules in reversed turn with index.\n\n # Example\n ```\n let sum = [1, 2, 3, 4, 5].rev_foldi(init=0, fn { index, sum, _elem => sum + index })\n assert_eq!(sum, 10)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::rev_foldi[A, B](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[A], init~ : B, f : (Int, B, A) -> B) -> B",
          "loc": { "line": 429, "column": 8 }
        },
        {
          "name": "rev_inplace",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::rev_inplace[T](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T]) -> Unit",
          "loc": { "line": 457, "column": 8 }
        },
        {
          "name": "search",
          "docstring": "\n Search the array index for a given element.\n\n # Example\n ```\n let arr: FixedArray[Int] = [3, 4, 5]\n assert_eq!(arr.search(3), Some(0))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::search[T : <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T], value : T) -> Int?",
          "loc": { "line": 659, "column": 8 }
        },
        {
          "name": "sort",
          "docstring": "\n Sorts the array\n \n It's an in-place, unstable sort(it will reorder equal elements). The time complexity is O(n log n) in the worst case.\n \n # Example\n \n ```\n let arr = [5, 4, 3, 2, 1]\n arr.sort()\n assert_eq!(arr, [1, 2, 3, 4, 5])\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::sort[T : <a href=\"moonbitlang/core/builtin#Compare\">Compare</a> + <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T]) -> Unit",
          "loc": { "line": 216, "column": 8 }
        },
        {
          "name": "sort_by",
          "docstring": "\n Sorts the array with a custom comparison function.\n \n It's an in-place, unstable sort(it will reorder equal elements). The time complexity is O(n log n) in the worst case.\n \n # Example\n \n ```\n let arr = [5, 3, 2, 4, 1]\n arr.sort_by(fn (a, b) { a - b })\n assert_eq!(arr, [1, 2, 3, 4, 5])\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::sort_by[T](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T], cmp : (T, T) -> Int) -> Unit",
          "loc": { "line": 60, "column": 8 }
        },
        {
          "name": "sort_by_key",
          "docstring": "\n Sorts the array with a key extraction function.\n \n It's an in-place, unstable sort(it will reorder equal elements). The time complexity is O(n log n) in the worst case.\n \n # Example\n \n ```\n let arr = [5, 3, 2, 4, 1]\n arr.sort_by_key(fn (x) {-x})\n assert_eq!(arr, [5, 4, 3, 2, 1])\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::sort_by_key[T, K : <a href=\"moonbitlang/core/builtin#Compare\">Compare</a> + <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T], map : (T) -> K) -> Unit",
          "loc": { "line": 27, "column": 8 }
        },
        {
          "name": "stable_sort",
          "docstring": "\n Sorts the array\n \n It's an stable sort(it will not reorder equal elements). The time complexity is *O*(*n* \\* log(*n*)) in the worst case.\n \n # Example\n \n ```\n let arr: FixedArray[Int] = [5, 4, 3, 2, 1]\n arr.stable_sort()\n assert_eq!(arr, [1, 2, 3, 4, 5])\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::stable_sort[T : <a href=\"moonbitlang/core/builtin#Compare\">Compare</a> + <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T]) -> Unit",
          "loc": { "line": 27, "column": 8 }
        },
        {
          "name": "starts_with",
          "docstring": "\n Check if the array starts with a given prefix.\n\n # Example\n ```\n let arr: FixedArray[Int] = [3, 4, 5]\n assert_true!(arr.starts_with([3, 4]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>::starts_with[T : <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T], prefix : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[T]) -> Bool",
          "loc": { "line": 729, "column": 8 }
        }
      ]
    }
  ]
}