<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Moonbit docs</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="Description">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/one-light.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script
    src="//cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
</head>

<body>
  <pre><code class="moonbit">// /* __ieee754_hypot(x,y)
//  *
//  * Method :                  
//  *	If (assume round-to-nearest) z=x*x+y*y 
//  *	has error less than sqrt(2)/2 ulp, than 
//  *	sqrt(z) has error less than 1 ulp (exercise).
//  *
//  *	So, compute sqrt(x*x+y*y) with some care as 
//  *	follows to get the error below 1 ulp:
//  *
//  *	Assume x>y>0;
//  *	(if possible, set rounding to round-to-nearest)
//  *	1. if x > 2y  use
//  *		x1*x1+(y*y+(x2*(x+x1))) for x*x+y*y
//  *	where x1 = x with lower 32 bits cleared, x2 = x-x1; else
//  *	2. if x <= 2y use
//  *		t1*y1+((x-y)*(x-y)+(t1*y2+t2*y))
//  *	where t1 = 2x with lower 32 bits cleared, t2 = 2x-t1, 
//  *	y1= y with lower 32 bits chopped, y2 = y-y1.
//  *		
//  *	NOTE: scaling may be necessary if some argument is too 
//  *	      large or too tiny
//  *
//  * Special cases:
//  *	hypot(x,y) is INF if x or y is +INF or -INF; else
//  *	hypot(x,y) is NAN if x or y is NAN.
//  *
//  * Accuracy:
//  * 	hypot(x,y) returns sqrt(x^2+y^2) with error less 
//  * 	than 1 ulps (units in the last place) 
//  */
//
// #include "fdlibm.h"
//
// #ifdef __STDC__
// 	double __ieee754_hypot(double x, double y)
// #else
// 	double __ieee754_hypot(x,y)
// 	double x, y;
// #endif
// {
// 	double a=x,b=y,t1,t2,y1,y2,w;
// 	int j,k,ha,hb;
//
// 	ha = __HI(x)&0x7fffffff;	/* high word of  x */
// 	hb = __HI(y)&0x7fffffff;	/* high word of  y */
// 	if(hb > ha) {a=y;b=x;j=ha; ha=hb;hb=j;} else {a=x;b=y;}
// 	__HI(a) = ha;	/* a <- |a| */
// 	__HI(b) = hb;	/* b <- |b| */
// 	if((ha-hb)>0x3c00000) {return a+b;} /* x/y > 2**60 */
// 	k=0;
// 	if(ha > 0x5f300000) {	/* a>2**500 */
// 	   if(ha >= 0x7ff00000) {	/* Inf or NaN */
// 	       w = a+b;			/* for sNaN */
// 	       if(((ha&0xfffff)|__LO(a))==0) w = a;
// 	       if(((hb^0x7ff00000)|__LO(b))==0) w = b;
// 	       return w;
// 	   }
// 	   /* scale a and b by 2**-600 */
// 	   ha -= 0x25800000; hb -= 0x25800000;	k += 600;
// 	   __HI(a) = ha;
// 	   __HI(b) = hb;
// 	}
// 	if(hb < 0x20b00000) {	/* b < 2**-500 */
// 	    if(hb <= 0x000fffff) {	/* subnormal b or 0 */	
// 		if((hb|(__LO(b)))==0) return a;
// 		t1=0;
// 		__HI(t1) = 0x7fd00000;	/* t1=2^1022 */
// 		b *= t1;
// 		a *= t1;
// 		k -= 1022;
// 	    } else {		/* scale a and b by 2^600 */
// 	        ha += 0x25800000; 	/* a *= 2^600 */
// 		hb += 0x25800000;	/* b *= 2^600 */
// 		k -= 600;
// 	   	__HI(a) = ha;
// 	   	__HI(b) = hb;
// 	    }
// 	}
//     /* medium size a and b */
// 	w = a-b;
// 	if (w>b) {
// 	    t1 = 0;
// 	    __HI(t1) = ha;
// 	    t2 = a-t1;
// 	    w  = sqrt(t1*t1-(b*(-b)-t2*(a+t1)));
// 	} else {
// 	    a  = a+a;
// 	    y1 = 0;
// 	    __HI(y1) = hb;
// 	    y2 = b - y1;
// 	    t1 = 0;
// 	    __HI(t1) = ha+0x00100000;
// 	    t2 = a - t1;
// 	    w  = sqrt(t1*y1-(w*(-w)-(t1*y2+t2*b)));
// 	}
// 	if(k!=0) {
// 	    t1 = 1.0;
// 	    __HI(t1) += (k<<20);
// 	    return t1*w;
// 	} else return w;
// }

///| Returns the square root of the sum of the squares of its arguments, hypot(x, y) = sqrt(x*x, y*y)
/// # Introduction
///
/// hypot return the square root of the sum of the squares of its arguments, the formula is:
///
/// $$hypot(x) = \sqrt{x^2 + y^2}$$
///
/// # Special cases
///
/// 1. If x or y is NaN, return NaN
/// 2. If x or y is inf, return +inf
///
/// # Accuracy
///
/// 2 ulps (units in the last place)
pub fn hypot(x: Double, y: Double) -> Double {
  let x = fabs(x)
  let y = fabs(y)

  if isinf(x) || isinf(y) {
    return double_pos_inf
  }

  let (x, y) = if y > x { (y, x) } else { (x, y) }

  if x * double_epsilon >= y {
    return x
  }

  let rat = y / x
  x * sqrt(1.0 + rat * rat)
}
</code></pre>
  <script>
    let moonbitLanguageFn = hljs => {
      return {
        case_insensitive: true,
        keywords: {
          keyword: 'func fn enum struct type if else match return continue break while let var interface pub priv readonly',
          literal: 'true false',
          type: "Int Int64 Double String Bool Char Bytes Option Array Result",
          built_in: 'lsl lsr asr shl shr land lor lxor Show Debug Hash Eq Compare Some None'
        },
        contains: [
          {
            scope: "char",
            begin: "'", end: "'"
          },
          {
            scope: "string",
            begin: "\"", end: "\""
          },
          {
            scope: "number",
            begin: "\\b\\d+(\\.\\d+)?\\b"
          },
          {
            scope: "codelink",
            match: /\<a href\="(?<link>[^<>]+?)"\>(?<code>[^\/<>]+?)\<\/a\>/g
          },
          hljs.COMMENT(
            '//', // begin
            '\n', // end
          )
        ]
      }
    }

    hljs.registerLanguage('moonbit', moonbitLanguageFn);
    hljs.highlightAll();
    hljs.initLineNumbersOnLoad();

    const number = window.location.href.split('#')[1];

    function waitForLineNumbers() {
      setTimeout(function () {
        const target = document.querySelector(`.hljs-ln-line[data-line-number="${number}"]`);
        if (target == null) waitForLineNumbers();
        else target.scrollIntoView();
      }, 50);
    }

    waitForLineNumbers()

  </script>
  <style>
    .hljs-ln-numbers {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    .hljs-ln-n {
      color: #ccc;
      border-right: 1px solid #dfdddd;
      margin-right: 1em;
      text-align: center;
      vertical-align: top;
      padding-right: 0.5em;
    }

    .hljs {
      background: none;
    }

    body {
      background-color: #fafafa;
    }
  </style>
</body>

</html>