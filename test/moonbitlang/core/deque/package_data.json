{
  "readme": "# Deque\n\nDeque is a double-ended queue implemented as a round-robin queue, supporting O(1) head or tail insertion and querying, just like double-ended queues in other languages(C++ std::deque / Rust VecDeque), here deque also supports random access.\n\n# Usage\n\n## Create\n\nYou can create a deque manually via the `new()` or construct it using the `of()`.\n\n```moonbit\nlet dv : @deque.T[Int] = @deque.new()\nlet dv = @deque.of([1, 2, 3, 4, 5])\n```\n\nIf you want to set the length at creation time to minimize expansion consumption, you can add parameter `capacity` to the `new()` function.\n\n```moonbit\nlet dv = @deque.new(capacity=10)\n```\n\n## Length & Capacity\n\nA deque is an indefinite-length, auto-expandable datatype. You can use `length()` to get the number of elements in the current queue, or `capacity()` to get the current capacity.\n\n```moonbit\nlet dv = @deque.of([1, 2, 3, 4, 5])\ndv.length() // 5\ndv.capacity() // 5\n```\n\nSimilarly, you can use the `is_empty` to determine whether the queue is empty.\n\n```moonbit\nlet dv : @deque[Int] = @deque.new()\ndv.is_empty() // true\n```\n\nYou can use `reserve_capacity` to reserve capacity, ensures that it can hold at least the number of elements\nspecified by the `capacity` argument.\n\n```moonbit\nlet dv = @deque.of([1])\ndv.reserve_capacity(10)\nprintln(dv.capacity()) // 10\n```\n\nAlso, you can use `shrink_to_fit` to shrink the capacity of the deque.\n\n```moonbit\nlet dv = @deque.new(capacity=10)\ndv.push_back(1)\ndv.push_back(2)\ndv.push_back(3)\nprintln(dv.capacity()) // 10\ndv.shrink_to_fit()\nprintln(dv.capacity()) // 3\n```\n\n## Front & Back & Get\n\nYou can use `front()` and `back()` to get the head and tail elements of the queue, respectively. Since the queue may be empty, their return values are both `Option`, or `None` if the queue is empty.\n\n```moonbit\nlet dv = @deque.of([1, 2, 3, 4, 5])\ndv.front() // Some(1)\ndv.back() // Some(5)\n```\n\nYou can also use `op_get` to access elements of the queue directly, but be careful not to cross the boundaries!\n\n```moonbit\nlet dv = @deque.of([1, 2, 3, 4, 5])\ndv[0] // 1\ndv[4] // 5\n```\n\n## Push & Set\n\nSince the queue is bi-directional, you can use `push_front()` and `push_back()` to add values to the head or tail of the queue, respectively.\n\n```moonbit\nlet dv = @deque.of([1, 2, 3, 4, 5])\ndv.push_front(6)\ndv.push_front(7)\ndv.push_back(8)\ndv.push_back(9)\n//now: 6 7 1 2 3 4 5 8 9\n```\n\nYou can also use `op_set` to set elements of the queue directly, but be careful not to cross the boundaries!\n\n```moonbit\nlet dv = @deque.of([1, 2, 3, 4, 5])\ndv[0] = 5\ndv[0] // 5\n```\n\n## Pop\n\nYou can use `pop_front()` and `pop_back()` to pop the element at the head or tail of the queue, respectively, and like [Front & Back](#Front & Back & Get), their return values are `Option`, loaded with the value of the element being popped.\n\n```moonbit\nlet dv = @deque.of([1, 2, 3, 4, 5])\nlet back = dv.pop_back() // Some(5)\ndv.back() // Some(4)\nlet front = dv.pop_front() //Some(1)\ndv.front() // Some(2)\ndv.length() // 3\n```\n\nIf you only want to pop an element without getting the return value, you can use `pop_front_exn()` with `pop_back_exn()`.\nThese two functions will panic if the queue is empty.\n\n```moonbit\nlet dv = @deque.of([1, 2, 3, 4, 5])\ndv.pop_front_exn()\ndv.front() // Some(2)\ndv.pop_back_exn()\ndv.back() // Some(3)\n```\n\n## Clear\n\nYou can use `clear` to clear a deque. But note that the memory it already occupies does not change.\n\n```moonbit\nlet dv = @deque.of([1, 2, 3, 4, 5])\ndv.clear()\ndv.is_empty() // true\n```\n\n## Equal\n\ndeque supports comparing them directly using `op_equal`.\n\n```moonbit\nlet dqa = @deque.of([1, 2, 3, 4, 5])\nlet dqb = @deque.of([1, 2, 3, 4, 5])\ndqa == dqb // true\n```\n\n## Iter & Map\n\ndeque supports vector-like `iter/iteri/map/mapi` functions and their inverse forms.\n\n```moonbit\n let dv = @deque.of([1, 2, 3, 4, 5])\n dv.each(fn(elem) { print(elem) })\n dv.eachi(fn(i, _elem) { print(i) })\n dv.map(fn(elem) { elem + 1 })\n dv.mapi(fn(i, elem) { elem + i })\n```\n\n## Search & Contains\n\nYou can use `contains()` to find out if a value is in the deque, or `search()` to find its index in the deque.\n\n```moonbit\nlet dv = @deque.of([1, 2, 3, 4, 5])\ndv.contains(1) // true\ndv.contains(6) // false\ndv.search(1) // Some(0)\ndv.search(6) // None\n```\n",
  "name": "moonbitlang/core/deque",
  "traits": [],
  "types": [
    {
      "name": "T",
      "docstring": "",
      "signature": "type T",
      "loc": { "line": 17, "column": 8 },
      "methods": [
        {
          "name": "as_views",
          "docstring": "\n Returns two array views that together represent all elements in the deque in\n their correct order. The first view contains elements from the head to the\n end of the internal buffer, and the second view contains any remaining\n elements from the start of the buffer.\n\n If the deque is empty, returns a pair of empty views. If all elements are\n contiguous in memory, the second view will be empty.\n\n Parameters:\n\n * `self` : The deque to be viewed.\n\n Returns a tuple of two array views that together contain all elements of the\n deque in order.\n\n Example:\n\n ```moonbit\n test \"T::as_views\" {\n   let dq = @deque.of([1, 2, 3, 4, 5])\n   let (v1, v2) = dq.as_views()\n   inspect!(v1.length(), content=\"5\")\n   inspect!(v2.length(), content=\"0\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::as_views[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A]) -> (<a href=\"moonbitlang/core/array#ArrayView\">ArrayView</a>[A], <a href=\"moonbitlang/core/array#ArrayView\">ArrayView</a>[A])",
          "loc": { "line": 403, "column": 11 }
        },
        {
          "name": "back",
          "docstring": "\n Return the back element from a deque, or `None` if it is empty.\n\n # Example\n ```\n let dv = @deque.of([1, 2, 3, 4, 5])\n assert_eq!(dv.back(), Some(5))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::back[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A]) -> A?",
          "loc": { "line": 140, "column": 8 }
        },
        {
          "name": "capacity",
          "docstring": "\n Returns the total number of elements the deque can hold without reallocating.",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::capacity[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A]) -> Int",
          "loc": { "line": 82, "column": 8 }
        },
        {
          "name": "clear",
          "docstring": "\n Clears the deque, removing all values.\n\n This method has no effect on the allocated capacity of the deque, only setting the length to 0.\n\n # Example\n ```\n let dv = @deque.of([1, 2, 3, 4, 5])\n dv.clear()\n assert_eq!(dv.length(), 0)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::clear[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A]) -> Unit",
          "loc": { "line": 504, "column": 8 }
        },
        {
          "name": "contains",
          "docstring": "\n Checks if the array contains an element.\n\n # Example\n ```\n let dv = @deque.of([3, 4, 5])\n assert_true!(dv.contains(3))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::contains[A : <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A], value : A) -> Bool",
          "loc": { "line": 605, "column": 8 }
        },
        {
          "name": "copy",
          "docstring": "\n Creates a new copy of this deque.",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::copy[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A]) -> <a href=\"moonbitlang/core/deque#T\">T</a>[A]",
          "loc": { "line": 46, "column": 11 }
        },
        {
          "name": "each",
          "docstring": "\n Iterates over the elements of the deque.\n\n # Example\n ```\n let dv = @deque.of([1, 2, 3, 4, 5])\n let mut sum = 0\n dv.each(fn (x) {sum = sum + x})\n assert_eq!(sum, 15)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::each[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A], f : (A) -> Unit) -> Unit",
          "loc": { "line": 439, "column": 8 }
        },
        {
          "name": "eachi",
          "docstring": "\n Iterates over the elements of the deque with index.\n\n # Example\n ```\n let dv = @deque.of([1, 2, 3, 4, 5])\n let mut idx_sum = 0\n dv.eachi(fn (i, _x) {idx_sum = idx_sum + i})\n assert_eq!(idx_sum, 10)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::eachi[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A], f : (Int, A) -> Unit) -> Unit",
          "loc": { "line": 455, "column": 8 }
        },
        {
          "name": "filter_map_inplace",
          "docstring": "\n Filters and maps elements in-place using a provided function. Modifies the\n deque to retain only elements for which the provided function returns `Some`,\n and updates those elements with the values inside the `Some` variant.\n\n Parameters:\n\n * `self` : The deque to be filtered and mapped.\n * `f` : A function that takes an element and returns either `Some` with a new\n value to replace the element, or `None` to remove the element.\n\n Example:\n\n ```moonbit\n test \"filter_map_inplace\" {\n   let dq = @deque.of([1, 2, 3, 4, 5])\n   dq.filter_map_inplace(fn(x) { if x % 2 == 0 { Some(x * 2) } else { None } })\n   inspect!(dq, content=\"@deque.of([4, 8])\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::filter_map_inplace[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A], f : (A) -> A?) -> Unit",
          "loc": { "line": 739, "column": 8 }
        },
        {
          "name": "from_array",
          "docstring": "\n Creates a new deque from an array.",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::from_array[A](arr : <a href=\"moonbitlang/core/array#Array\">Array</a>[A]) -> <a href=\"moonbitlang/core/deque#T\">T</a>[A]",
          "loc": { "line": 31, "column": 11 }
        },
        {
          "name": "from_iter",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::from_iter[A](iter : <a href=\"moonbitlang/core/builtin#Iter\">Iter</a>[A]) -> <a href=\"moonbitlang/core/deque#T\">T</a>[A]",
          "loc": { "line": 938, "column": 11 }
        },
        {
          "name": "front",
          "docstring": "\n Return the front element from a deque, or `None` if it is empty.\n\n # Example\n ```\n let dv = @deque.of([1, 2, 3, 4, 5])\n assert_eq!(dv.front(), Some(1))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::front[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A]) -> A?",
          "loc": { "line": 124, "column": 8 }
        },
        {
          "name": "is_empty",
          "docstring": "\n Test if the deque is empty.\n\n # Example\n ```\n let dv = @deque.new()\n assert_eq!(dv.is_empty(), true)\n dv.push_back(1)\n assert_eq!(dv.is_empty(), false)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::is_empty[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A]) -> Bool",
          "loc": { "line": 577, "column": 8 }
        },
        {
          "name": "iter",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::iter[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A]) -> <a href=\"moonbitlang/core/builtin#Iter\">Iter</a>[A]",
          "loc": { "line": 832, "column": 8 }
        },
        {
          "name": "iter2",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::iter2[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A]) -> <a href=\"moonbitlang/core/builtin#Iter2\">Iter2</a>[Int, A]",
          "loc": { "line": 858, "column": 8 }
        },
        {
          "name": "length",
          "docstring": "\n Returns the deque of elements in the vector.",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::length[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A]) -> Int",
          "loc": { "line": 76, "column": 8 }
        },
        {
          "name": "map",
          "docstring": "\n Maps a function over the elements of the deque.\n\n # Example\n ```\n let dv = @deque.of([3, 4, 5])\n let dv2 = dv.map(fn (x) {x + 1})\n assert_eq!(dv2, @deque.of([4, 5, 6]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::map[A, U](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A], f : (A) -> U) -> <a href=\"moonbitlang/core/deque#T\">T</a>[U]",
          "loc": { "line": 534, "column": 8 }
        },
        {
          "name": "mapi",
          "docstring": "\n Maps a function over the elements of the deque with index.\n\n # Example\n ```\n let dv = @deque.of([3, 4, 5])\n let dv2 = dv.mapi(fn (i, x) {x + i}) // @deque.of([3, 5, 7])\n assert_eq!(dv2, @deque.of([3, 5, 7]))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::mapi[A, U](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A], f : (Int, A) -> U) -> <a href=\"moonbitlang/core/deque#T\">T</a>[U]",
          "loc": { "line": 555, "column": 8 }
        },
        {
          "name": "new",
          "docstring": "\n Creates a new, empty deque.",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::new[A](capacity~ : Int = ..) -> <a href=\"moonbitlang/core/deque#T\">T</a>[A]",
          "loc": { "line": 20, "column": 11 }
        },
        {
          "name": "of",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::of[A](arr : <a href=\"moonbitlang/core/array#FixedArray\">FixedArray</a>[A]) -> <a href=\"moonbitlang/core/deque#T\">T</a>[A]",
          "loc": { "line": 61, "column": 11 }
        },
        {
          "name": "op_equal",
          "docstring": "\n Compares two deques for equality.",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::op_equal[A : <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A], other : <a href=\"moonbitlang/core/deque#T\">T</a>[A]) -> Bool",
          "loc": { "line": 417, "column": 8 }
        },
        {
          "name": "op_get",
          "docstring": "\n Retrieves the element at the specified index from the deque.\n\n If you try to access an index which isn’t in the Deque, it will panic.\n\n # Example\n ```\n let dv = @deque.of([1, 2, 3, 4, 5])\n assert_eq!(dv[2], 3)\n ```\n @alert unsafe \"Panic if the index is out of bounds.\"",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::op_get[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A], index : Int) -> A",
          "loc": { "line": 337, "column": 8 }
        },
        {
          "name": "op_set",
          "docstring": "\n Sets the value of the element at the specified index.\n\n If you try to access an index which isn’t in the Deque, it will panic.\n\n # Example\n ```\n let dv = @deque.of([1, 2, 3, 4, 5])\n dv[2] = 1\n assert_eq!(dv[2], 1)\n ```\n @alert unsafe \"Panic if the index is out of bounds.\"",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::op_set[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A], index : Int, value : A) -> Unit",
          "loc": { "line": 363, "column": 8 }
        },
        {
          "name": "pop_back",
          "docstring": "\n Removes a back element from a deque and returns it, or `None` if it is empty.\n\n # Example\n ```\n let dv = @deque.of([1, 2, 3, 4, 5])\n assert_eq!(dv.pop_back(), Some(5))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::pop_back[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A]) -> A?",
          "loc": { "line": 303, "column": 8 }
        },
        {
          "name": "pop_back_exn",
          "docstring": "\n @alert deprecated \"Use `unsafe_pop_back` instead\"\n @coverage.skip",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::pop_back_exn[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A]) -> Unit",
          "loc": { "line": 260, "column": 8 }
        },
        {
          "name": "pop_front",
          "docstring": "\n Removes a front element from a deque and returns it, or `None` if it is empty.\n\n # Example\n ```\n let dv = @deque.of([1, 2, 3, 4, 5])\n assert_eq!(dv.pop_front(), Some(1))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::pop_front[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A]) -> A?",
          "loc": { "line": 272, "column": 8 }
        },
        {
          "name": "pop_front_exn",
          "docstring": "\n @alert deprecated \"Use `unsafe_pop_front` instead\"\n @coverage.skip",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::pop_front_exn[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A]) -> Unit",
          "loc": { "line": 224, "column": 8 }
        },
        {
          "name": "push_back",
          "docstring": "\n Adds an element to the back of the deque.\n\n If the deque is at capacity, it will be reallocated.\n\n # Example\n ```\n let dv = @deque.of([1, 2, 3, 4, 5])\n dv.push_back(6)\n assert_eq!(dv.back(), Some(6))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::push_back[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A], value : A) -> Unit",
          "loc": { "line": 181, "column": 8 }
        },
        {
          "name": "push_front",
          "docstring": "\n Adds an element to the front of the deque.\n\n If the deque is at capacity, it will be reallocated.\n\n # Example\n ```\n let dv = @deque.of([1, 2, 3, 4, 5])\n dv.push_front(0)\n assert_eq!(dv.front(), Some(0))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::push_front[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A], value : A) -> Unit",
          "loc": { "line": 159, "column": 8 }
        },
        {
          "name": "reserve_capacity",
          "docstring": "\n Reserves capacity to ensure that it can hold at least the number of elements\n specified by the `capacity` argument.\n\n # Example\n\n ```\n let dv = @deque.of([1])\n dv.reserve_capacity(10)\n assert_eq!(dv.capacity(), 10)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::reserve_capacity[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A], capacity : Int) -> Unit",
          "loc": { "line": 620, "column": 8 }
        },
        {
          "name": "retain",
          "docstring": "\n Filters elements in-place by retaining only the elements that satisfy the\n given predicate. Modifies the deque to keep only the elements for which the\n predicate function returns `true`.\n\n Parameters:\n\n * `self` : The deque to be filtered.\n * `predicate` : A function that takes an element and returns `true` if the\n element should be kept, `false` if it should be removed.\n\n Example:\n\n ```moonbit\n test \"retain\" {\n   let dq = @deque.of([1, 2, 3, 4, 5])\n   dq.retain(fn(x) { x % 2 == 0 })\n   inspect!(dq, content=\"@deque.of([2, 4])\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::retain[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A], f : (A) -> Bool) -> Unit",
          "loc": { "line": 798, "column": 8 }
        },
        {
          "name": "rev_each",
          "docstring": "\n Iterates over the elements of the deque in reversed turn.\n\n # Example\n ```\n let dv = @deque.of([1, 2, 3, 4, 5])\n let mut sum = 0\n dv.rev_each(fn (x) {sum = sum + x})\n assert_eq!(sum, 15)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::rev_each[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A], f : (A) -> Unit) -> Unit",
          "loc": { "line": 471, "column": 8 }
        },
        {
          "name": "rev_eachi",
          "docstring": "\n Iterates over the elements of the deque in reversed turn with index.\n\n # Example\n ```\n let dv = @deque.of([1, 2, 3, 4, 5])\n let mut idx_sum = 0\n dv.rev_eachi(fn (i, _x) {idx_sum = idx_sum + i})\n assert_eq!(idx_sum, 10)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::rev_eachi[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A], f : (Int, A) -> Unit) -> Unit",
          "loc": { "line": 487, "column": 8 }
        },
        {
          "name": "rev_iter",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::rev_iter[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A]) -> <a href=\"moonbitlang/core/builtin#Iter\">Iter</a>[A]",
          "loc": { "line": 885, "column": 8 }
        },
        {
          "name": "rev_iter2",
          "docstring": "",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::rev_iter2[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A]) -> <a href=\"moonbitlang/core/builtin#Iter2\">Iter2</a>[Int, A]",
          "loc": { "line": 911, "column": 8 }
        },
        {
          "name": "search",
          "docstring": "\n\n # Example\n ```\n let dv = @deque.of([3, 4, 5])\n assert_eq!(dv.search(3), Some(0))\n ```",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::search[A : <a href=\"moonbitlang/core/builtin#Eq\">Eq</a>](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A], value : A) -> Int?",
          "loc": { "line": 588, "column": 8 }
        },
        {
          "name": "shrink_to_fit",
          "docstring": "\n Shrinks the capacity of the deque as much as possible.\n\n # Example\n\n ```\n let dv = @deque.new(capacity=10)\n dv.push_back(1)\n dv.push_back(2)\n dv.push_back(3)\n assert_eq!(dv.capacity(), 10)\n dv.shrink_to_fit()\n assert_eq!(dv.capacity(), 3)\n ```",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::shrink_to_fit[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A]) -> Unit",
          "loc": { "line": 650, "column": 8 }
        },
        {
          "name": "truncate",
          "docstring": "\n Shortens the deque in-place, keeping the first `len` elements and dropping\n the rest.\n\n If `len` is greater than or equal to the deque's current length, this has no\n effect.\n\n Parameters:\n\n * `self` : The deque to be truncated.\n * `len` : The new length of the deque.\n\n Example:\n\n ```moonbit\n test \"truncate\" {\n   let dq = @deque.of([1, 2, 3, 4, 5])\n   dq.truncate(3)\n   inspect!(dq, content=\"@deque.of([1, 2, 3])\")\n }\n ```",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::truncate[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A], len : Int) -> Unit",
          "loc": { "line": 685, "column": 8 }
        },
        {
          "name": "unsafe_pop_back",
          "docstring": "\n Removes a back element from a deque.\n\n # Example\n ```\n let dv = @deque.of([1, 2, 3, 4, 5])\n dv.unsafe_pop_back()\n assert_eq!(dv.back(), Some(4))\n ```\n @alert unsafe \"Panic if the deque is empty.\"",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::unsafe_pop_back[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A]) -> Unit",
          "loc": { "line": 238, "column": 8 }
        },
        {
          "name": "unsafe_pop_front",
          "docstring": "\n Removes a front element from a deque.\n\n # Example\n ```\n let dv = @deque.of([1, 2, 3, 4, 5])\n dv.unsafe_pop_front()\n assert_eq!(dv.front(), Some(2))\n ```\n @alert unsafe \"Panic if the deque is empty.\"",
          "signature": "fn <a href=\"moonbitlang/core/deque#T\">T</a>::unsafe_pop_front[A](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A]) -> Unit",
          "loc": { "line": 202, "column": 8 }
        }
      ],
      "impls": [
        {
          "docstring": "",
          "signature": "impl[A : <a href=\"moonbitlang/core/builtin#Show\">Show</a>] <a href=\"moonbitlang/core/builtin#Show\">Show</a> for <a href=\"moonbitlang/core/deque#T\">T</a>[A]",
          "methods": [
            {
              "name": "output",
              "docstring": "",
              "signature": "fn output[A : <a href=\"moonbitlang/core/builtin#Show\">Show</a>](self : <a href=\"moonbitlang/core/deque#T\">T</a>[A], logger : <a href=\"moonbitlang/core/builtin#Logger\">Logger</a>) -> Unit",
              "loc": { "line": 25, "column": 39 }
            }
          ],
          "loc": { "line": 25, "column": 1 }
        }
      ]
    }
  ],
  "typealias": [],
  "values": [],
  "misc": []
}