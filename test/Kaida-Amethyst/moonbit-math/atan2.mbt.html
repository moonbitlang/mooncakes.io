<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Moonbit docs</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="Description">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/one-light.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script
    src="//cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
</head>

<body>
  <pre><code class="moonbit">// /* __ieee754_atan2(y,x)
//  * Method :
//  *	1. Reduce y to positive by atan2(y,x)=-atan2(-y,x).
//  *	2. Reduce x to positive by (if x and y are unexceptional): 
//  *		ARG (x+iy) = arctan(y/x)   	   ... if x > 0,
//  *		ARG (x+iy) = pi - arctan[y/(-x)]   ... if x < 0,
//  *
//  * Special cases:
//  *
//  *	ATAN2((anything), NaN ) is NaN;
//  *	ATAN2(NAN , (anything) ) is NaN;
//  *	ATAN2(+-0, +(anything but NaN)) is +-0  ;
//  *	ATAN2(+-0, -(anything but NaN)) is +-pi ;
//  *	ATAN2(+-(anything but 0 and NaN), 0) is +-pi/2;
//  *	ATAN2(+-(anything but INF and NaN), +INF) is +-0 ;
//  *	ATAN2(+-(anything but INF and NaN), -INF) is +-pi;
//  *	ATAN2(+-INF,+INF ) is +-pi/4 ;
//  *	ATAN2(+-INF,-INF ) is +-3pi/4;
//  *	ATAN2(+-INF, (anything but,0,NaN, and INF)) is +-pi/2;
//  *
//  * Constants:
//  * The hexadecimal values are the intended ones for the following 
//  * constants. The decimal values may be used, provided that the 
//  * compiler will convert from decimal to binary accurately enough 
//  * to produce the hexadecimal values shown.
//  */
//
// #include "fdlibm.h"
//
// #ifdef __STDC__
// static const double 
// #else
// static double 
// #endif
// tiny  = 1.0e-300,
// zero  = 0.0,
// pi_o_4  = 7.8539816339744827900E-01, /* 0x3FE921FB, 0x54442D18 */
// pi_o_2  = 1.5707963267948965580E+00, /* 0x3FF921FB, 0x54442D18 */
// pi      = 3.1415926535897931160E+00, /* 0x400921FB, 0x54442D18 */
// pi_lo   = 1.2246467991473531772E-16; /* 0x3CA1A626, 0x33145C07 */
//
// #ifdef __STDC__
// 	double __ieee754_atan2(double y, double x)
// #else
// 	double __ieee754_atan2(y,x)
// 	double  y,x;
// #endif
// {  
// 	double z;
// 	int k,m,hx,hy,ix,iy;
// 	unsigned lx,ly;
//
// 	hx = __HI(x); ix = hx&0x7fffffff;
// 	lx = __LO(x);
// 	hy = __HI(y); iy = hy&0x7fffffff;
// 	ly = __LO(y);
// 	if(((ix|((lx|-lx)>>31))>0x7ff00000)||
// 	   ((iy|((ly|-ly)>>31))>0x7ff00000))	/* x or y is NaN */
// 	   return x+y;
// 	if((hx-0x3ff00000|lx)==0) return atan(y);   /* x=1.0 */
// 	m = ((hy>>31)&1)|((hx>>30)&2);	/* 2*sign(x)+sign(y) */
//
//     /* when y = 0 */
// 	if((iy|ly)==0) {
// 	    switch(m) {
// 		case 0: 
// 		case 1: return y; 	/* atan(+-0,+anything)=+-0 */
// 		case 2: return  pi+tiny;/* atan(+0,-anything) = pi */
// 		case 3: return -pi-tiny;/* atan(-0,-anything) =-pi */
// 	    }
// 	}
//     /* when x = 0 */
// 	if((ix|lx)==0) return (hy<0)?  -pi_o_2-tiny: pi_o_2+tiny;
// 	    
//     /* when x is INF */
// 	if(ix==0x7ff00000) {
// 	    if(iy==0x7ff00000) {
// 		switch(m) {
// 		    case 0: return  pi_o_4+tiny;/* atan(+INF,+INF) */
// 		    case 1: return -pi_o_4-tiny;/* atan(-INF,+INF) */
// 		    case 2: return  3.0*pi_o_4+tiny;/*atan(+INF,-INF)*/
// 		    case 3: return -3.0*pi_o_4-tiny;/*atan(-INF,-INF)*/
// 		}
// 	    } else {
// 		switch(m) {
// 		    case 0: return  zero  ;	/* atan(+...,+INF) */
// 		    case 1: return -zero  ;	/* atan(-...,+INF) */
// 		    case 2: return  pi+tiny  ;	/* atan(+...,-INF) */
// 		    case 3: return -pi-tiny  ;	/* atan(-...,-INF) */
// 		}
// 	    }
// 	}
//     /* when y is INF */
// 	if(iy==0x7ff00000) return (hy<0)? -pi_o_2-tiny: pi_o_2+tiny;
//
//     /* compute y/x */
// 	k = (iy-ix)>>20;
// 	if(k > 60) z=pi_o_2+0.5*pi_lo; 	/* |y/x| >  2**60 */
// 	else if(hx<0&&k<-60) z=0.0; 	/* |y|/x < -2**60 */
// 	else z=atan(fabs(y/x));		/* safe to do y/x */
// 	switch (m) {
// 	    case 0: return       z  ;	/* atan(+,+) */
// 	    case 1: __HI(z) ^= 0x80000000;
// 		    return       z  ;	/* atan(-,+) */
// 	    case 2: return  pi-(z-pi_lo);/* atan(+,-) */
// 	    default: /* case 3 */
// 	    	    return  (z-pi_lo)-pi;/* atan(-,-) */
// 	}
// }

///| `atan2(y, x)` returns the angle whose tangent is `y/x`.
/// # Special Cases:
///
/// 1. `atan2((anything), NaN)` is NaN;
/// 2. `atan2(NAN, (anything))` is NaN;
/// 3. `atan2(+-0, +(anything but NaN))` is +-0;
/// 4. `atan2(+-0, -(anything but NaN))` is +-pi;
/// 5. `atan2(+-(anything but 0 and NaN), 0)` is +-pi/2;
/// 6. `atan2(+-(anything but INF and NaN), +INF)` is +-0;
/// 7. `atan2(+-(anything but INF and NaN), -INF)` is +-pi;
/// 8. `atan2(+-INF,+INF)` is +-pi/4;
/// 9. `atan2(+-INF,-INF)` is +-3pi/4;
/// 10. `atan2(+-INF, (anything but,0,NaN, and INF))` is +-pi/2;
pub fn atan2(y : Double, x : Double) -> Double {
  if isnan(x) || isnan(y) {
    double_nan
  } else if y == 0 {
    if x >= 0 {
      copysign(0, y)
    } else {
      copysign(PI, y)
    }
  } else if x == 0 {
    copysign(PI_OVER_2, y)
  } else if isinf(x) {
    if x.is_pos_inf() {
      if isinf(y) {
        copysign(PI_OVER_4, y)
      } else {
        copysign(0, y)
      }
    } else if isinf(y) {
      copysign(3.0 * PI_OVER_4, y)
    } else {
      copysign(PI, y)
    }
  } else if isinf(y) {
    copysign(PI_OVER_2, y)
  } else {
    let q = atan(y / x)
    if x < 0 {
      if q <= 0 {
        q + PI
      } else {
        q - PI
      }
    } else {
      q
    }
  }
}
</code></pre>
  <script>
    let moonbitLanguageFn = hljs => {
      return {
        case_insensitive: true,
        keywords: {
          keyword: 'func fn enum struct type if else match return continue break while let var interface pub priv readonly',
          literal: 'true false',
          type: "Int Int64 Double String Bool Char Bytes Option Array Result",
          built_in: 'lsl lsr asr shl shr land lor lxor Show Debug Hash Eq Compare Some None'
        },
        contains: [
          {
            scope: "char",
            begin: "'", end: "'"
          },
          {
            scope: "string",
            begin: "\"", end: "\""
          },
          {
            scope: "number",
            begin: "\\b\\d+(\\.\\d+)?\\b"
          },
          {
            scope: "codelink",
            match: /\<a href\="(?<link>[^<>]+?)"\>(?<code>[^\/<>]+?)\<\/a\>/g
          },
          hljs.COMMENT(
            '//', // begin
            '\n', // end
          )
        ]
      }
    }

    hljs.registerLanguage('moonbit', moonbitLanguageFn);
    hljs.highlightAll();
    hljs.initLineNumbersOnLoad();

    const number = window.location.href.split('#')[1];

    function waitForLineNumbers() {
      setTimeout(function () {
        const target = document.querySelector(`.hljs-ln-line[data-line-number="${number}"]`);
        if (target == null) waitForLineNumbers();
        else target.scrollIntoView();
      }, 50);
    }

    waitForLineNumbers()

  </script>
  <style>
    .hljs-ln-numbers {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    .hljs-ln-n {
      color: #ccc;
      border-right: 1px solid #dfdddd;
      margin-right: 1em;
      text-align: center;
      vertical-align: top;
      padding-right: 0.5em;
    }

    .hljs {
      background: none;
    }

    body {
      background-color: #fafafa;
    }
  </style>
</body>

</html>